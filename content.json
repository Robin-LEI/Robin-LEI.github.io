{"meta":{"title":"Robin LEI","subtitle":"用代码改变世界，因为喜欢所以热爱!","description":null,"author":"Robin LEI","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-08-29T14:55:28.000Z","updated":"2019-08-29T14:56:01.156Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-29T14:55:41.000Z","updated":"2019-08-29T14:56:45.662Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HTML","slug":"html","date":"2019-09-27T12:32:00.000Z","updated":"2019-09-27T12:35:53.965Z","comments":true,"path":"2019/09/27/html/","link":"","permalink":"http://yoursite.com/2019/09/27/html/","excerpt":"","text":"浏览器内核 trident: 1997开始在ie使用 blink:Google,2013年之前用的是webkit webkit:safari gecko:Firefox presto:opera servo:mozilla和三星达成协议,准备开发下一代浏览器内核servo DTD 主要是为了告诉浏览器采用哪种模式(或规范)解析页面 web浏览器布局引擎有三种模式: 怪异模式,quirks mode 混杂模式,almost standards mode,准标准模式 标准模式,full standards mode 如果不写dtd,浏览器就会按照自己的方式去解析页面,因为不同的浏览器有自己不同的解析方式,所以会导致同一个页面在不同浏览器出现不一致的样式,这称之为quirks mode 如果写了dtd声明,浏览器就会按照W3C的标准规范去解析页面 在IE6之前,是不存在dtd模式的,之前的布局都是采用旧的一种布局方式,在IE6之后,出现了dtd模式,此时为了兼容之前的网页,就在顶部加了来区分 src与href src会替换当前元素 href会在当前文档和引用资源之间确立联系 src串行加载资源,会把指向的资源下载到当前文档内,同时会阻塞当前文档的正常渲染,例如js脚本,image,frame href是并行加载 link与@import link没有兼容性,属于xhtml与html标签,不仅可以对css引入,还可以定义rss(聚合内容),还支持使用JavaScript来操作dom控制元素样式 @import存在兼容性,在CSS2.1后引入,只是单纯的css标签,不支持js操作 block formatting context 可以看作一个沙箱 不论内部元素如何变动均不会改变外部布局 根元素body,position:absolute/fixed,float:left/right,display:inline-block/table会触发BFC 内部盒子会垂直排列,两个盒子的间距由margin决定,但是margin会发生合并,可以设置overflow解决 html与xhtml html对开发者比较宽容,写法上没有xhtml严格 xhtml不支持标签大写,也不允许大小写混合写 xhtml标签上只允许使用双引号 xhtml不支持target=_blank,可以设置rel=”external”配合JavaScript使用 opacity和rgba() opacity会穿透 rgba不会 如何让一个元素水平垂直居中 使用position:relative;position:absolute;transform:translate(-50%) 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; position: relative; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 使用display:flex; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; display: flex; justify-content: center; align-items: center; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; top:0;right:0;bottom:0;left:0;margin:auto; 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; position: relative; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; position: absolute; /* 遮罩,充满整个父级元素大小 */ top: 0; right: 0; bottom: 0; left: 0; /* 会使得上下,左右平分剩余空间 */ margin: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; display:table-cell;text-align:center;vertical-align:middle; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; display: table-cell; text-align: center; vertical-align: middle; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; display: inline-block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; H5C3 H5新特性:增强型表单控件,语义化标签,拖拽,地理定位,canvas,websocket,webworker,localstorage,音频/视频 C3新特性:rgba,text-shadow,box-shadow,border-radius,border-image,border-color,transform,transition,animation","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"前端模块化","slug":"module","date":"2019-09-25T14:42:33.000Z","updated":"2019-09-25T14:58:50.052Z","comments":true,"path":"2019/09/25/module/","link":"","permalink":"http://yoursite.com/2019/09/25/module/","excerpt":"","text":"背景 最早的就是单纯的写代码(非常容易污染全局环境) 然后演化到了使用命名空间的形式去简单包装，但是本质上也还是对象，仍然不安全 然后演化到了使用匿名闭包(IIFE模式) 在增强到引入依赖 全局函数模式 将不同的功能封装在不同的全局函数里 非常容易覆盖，不管是函数名还是变量 namespace 仍然可以操作对象，修改数据 匿名函数自调用 想让外面拿到数据，就得通过window暴露 IIFE 引入依赖 现代模块实现的基石1234567(function(window, $) &#123; let name = &apos;test&apos; function foo() &#123; console.log(name) &#125; $(&apos;body&apos;).css(&apos;background&apos;: &apos;red&apos;)&#125;)(window, jQuery) commonjs nodejs就是基于这种 每一个文件都是一个模块 模块分为第三方模块和自定义模块 module.exports和exports.xxx都可以导出，但是本质上导出的是exports 在浏览器端如果需要使用commonjs需要引入browserify浏览器打包工具 执行browser js/src/index.js -o js/dist/bundle.js AMD 专门用在浏览器端 异步加载模块 模块分为无依赖模块和有依赖模块 需要引入require.js库 在没有引入AMD概念之前，前端js模块之间的引入十分恶心，对于错综复杂的项目依赖之间容易搞混，会导致页面上引入过多的script标签，而script标签又会导致页面请求次数过多，影响性能 jquery内置支持AMD CMD 依赖sea.js库 借鉴了commonJS和CMD 可以同步加载模块也可以异步加载模块 ES6 export导出 import导入 在浏览器不支持es6语法的时候，需要引入babel转换工具，需要安装： 12npm i babel-cli browserify -gnpm i babel-preset-es2015 -S 注意babel只能编译文件，不能新建文件夹","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"}]},{"title":"mock","slug":"mock","date":"2019-09-24T13:10:50.000Z","updated":"2019-09-24T13:11:17.821Z","comments":true,"path":"2019/09/24/mock/","link":"","permalink":"http://yoursite.com/2019/09/24/mock/","excerpt":"","text":"背景 快速构建restful api，完成前后端分离开发 前后端分离开发方案mock 和后端约定好接口的标准 后端开始开发接口 前端通过假数据方式模拟一个后端接口 使用http-server搭建静态资源服务器、live-server第三方mock工具 mock.js(无法持久化数据) json-server 使用mock http://mockjs.com 引入mock.js后，会有一个全局对象Mock Mock.mock(‘/users’, ‘get’, {hello: ‘world’})1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;mock&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Mock.mock(&apos;/details&apos;, &apos;get&apos;, Mock.mock(&#123; &quot;name|1-10&quot;: &quot;*&quot;, &quot;age|1-20&quot;: 1 &#125;)) $.get(&apos;/details&apos;, (res) =&gt; &#123; console.log(&apos;res&apos;, res) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; json-server GitHub json文件中每一个名字都是一个资源 restful 面向资源编程 资源指的就是一类数据 最重要的是如何去表示一个资源(地址即资源)","categories":[],"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-hooks","slug":"react-hooks","date":"2019-09-22T13:39:19.000Z","updated":"2019-09-22T13:39:48.893Z","comments":true,"path":"2019/09/22/react-hooks/","link":"","permalink":"http://yoursite.com/2019/09/22/react-hooks/","excerpt":"","text":"背景 用函数替代了类 方法即组件 useState 不能存在于if语句中 react自带的一个hook函数，用来声明状态变量 const [count, setCount] = useState(0) 该函数接受的参数是状态的初始值，返回一个数组，数组的第0位是当前的初始值，第1位是改变状态值的方法函数 useEffect 等于componentDidMount和componentDidUpdate 在组件挂载和更新时触发 组件销毁 componentWillUnmount 使用useEffect，当组件销毁时执行1234567891011121314151617181920function Index() &#123; useEffect(() =&gt; &#123; console.log(&apos;组件挂载时执行&apos;) return () =&gt; &#123; console.log(&apos;组件卸载时执行&apos;) &#125; &#125;) return (&lt;h1&gt;这是Index页面&lt;h1&gt;)&#125;// 但是当我们每次改变数据时，会打印console.log(&apos;组件挂载时执行&apos;)，解决办法如下：// 需要借助于useEffect的返回函数的第二个参数，第二个参数可以写入很多状态对应的变量，意思是当状态值发生改变时才进行解绑，但是我们如何传入一个[]作为第二个参数时，就是当组件将被销毁时才进行解绑function Index() &#123; useEffect(()=&gt;&#123; console.log(&apos;组件挂载时执行&apos;) return ()=&gt;&#123; console.log(&apos;组件卸载时执行&apos;) &#125; &#125;,[]) return (&lt;h1&gt;这是Index页面&lt;h1&gt;)&#125; useContext 解决父子组件传值 可以实现跨层级的组件传值问题 可以访问全局状态，避免数据一层层的传递，和redux类似(状态的全局化，并且可以统一管理)123456789101112131415161718192021222324252627282930import React, &#123;createContext,useContext,useState&#125; from &apos;react&apos;const CountContext = createContext()// 子组件function Children() &#123; let count = useContext(CountContext) return ( &lt;&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;h3&gt;&#123;count&#125;&lt;/h3&gt; &lt;/&gt; )&#125;function Parent() &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;h1&gt;这是parent组件&lt;/h1&gt; &lt;h2&gt;次数:&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count+1)&#125;&#125;&gt;点击使得次数增加&lt;/button&gt; &lt;CountContext.Provider value=&#123;count&#125;&gt; &lt;Children /&gt; &lt;/CountContext.Provider&gt; &lt;/&gt; )&#125;export default Parent useReducer 通过action的传递，更新复杂逻辑的状态 控制业务逻辑1234567891011121314151617181920212223242526import React, &#123;useReducer&#125; from &apos;react&apos;function UseReducer() &#123; const [count, dispatch] = useReducer((state, action) =&gt; &#123; switch(action) &#123; case &apos;add&apos;: return state + 1 break case &apos;minus&apos;: return state - 1 break default: return state break &#125; &#125;, 0) return ( &lt;&gt; &lt;h1&gt;这是第几次&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&apos;add&apos;)&#125;&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&apos;minus&apos;)&#125;&#125;&gt;minus&lt;/button&gt; &lt;/&gt; )&#125;export default UseReducer useMemo解决子组件重复执行的问题 常常用于缓存变量123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父组件import React, &#123; useState &#125; from &apos;react&apos;;import UseMemoChild from &apos;./useMemoChild&apos;function UseMemo() &#123; const [A, setA] = useState(&apos;这是A&apos;) const [B, setB] = useState(&apos;这是B&apos;) return ( &lt;&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;setA(new Date().getTime()+&apos;点击了A&apos;)&#125;&#125;&gt;点击A&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;setB(new Date().valueOf()+&apos;点击了B&apos;)&#125;&#125;&gt;点击B&lt;/button&gt; &lt;UseMemoChild isA=&#123;A&#125; &gt;&#123;B&#125;&lt;/UseMemoChild&gt; &lt;/&gt; )&#125;export default UseMemo// 子组件import React, &#123;useMemo&#125; from &apos;react&apos;;function UseMemoChild(&#123;isA, children&#125;) &#123; function handleAMethods(isA) &#123; console.log(`执行了A的处理方法:$&#123;isA&#125;`) return `执行了A的处理方法:$&#123;isA&#125;` &#125; // 优化前 // const handleA = handleAMethods(isA) // 优化后 const handleA = useMemo(() =&gt; &#123; return handleAMethods(isA) &#125;, [isA]) return ( &lt;&gt; &lt;h2&gt;这是子组件页面&lt;/h2&gt; &lt;h3&gt;接收到父组件数据A：&#123;handleA&#125;&lt;/h3&gt; &lt;h3&gt;接收到父组件数据B：&#123;children&#125;&lt;/h3&gt; &lt;/&gt; )&#125;export default UseMemoChild useRef 获取dom元素 一般不推荐此操作 useCallback 缓存方法 提升性能，避免不必要的问题出现 优化react hooks程序性能 使用function的形式编写组件，使得我们丢了shouldComponentUpdate这个生命周期函数 也就是我们没有办法在组件更新之前去控制这个组件是不是要重新渲染 在函数组件中，也没有了mount和update两个状态，这意味着函数组件的每一次执行都会执行内部的所有逻辑，就带来了非常大的性能损耗 使用useMemo和useCallback就可以解决这个性能问题 自定义hooks函数 自定义的hooks函数偏向于功能 组件偏向于界面和业务逻辑的实现 往往使用use开头命名，这样才能更好的区分组件和自定义hooks函数1234567891011121314151617181920212223242526272829import React, &#123;useState, useEffect, useCallback&#125; from &apos;react&apos;;function useWinSize() &#123; const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) const onResize = useCallback(() =&gt; &#123; setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) &#125;) useEffect(() =&gt; &#123; window.addEventListener(&apos;resize&apos;, onResize) return () =&gt; &#123; window.removeEventListener(&apos;resize&apos;, onResize) &#125; &#125;, []) return size&#125;function Hooks() &#123; const size = useWinSize() return ( &lt;&gt; &lt;h1&gt;当前的浏览器的尺寸大小是: &#123;size.width&#125; x &#123;size.height&#125;&lt;/h1&gt; &lt;/&gt; )&#125;export default Hooks demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// index.jsimport React from &apos;react&apos;import Info from &apos;./info&apos;import Buttons from &apos;./buttons&apos;import &#123;Color&#125; from &apos;./color&apos;function Home() &#123; return ( &lt;&gt; &lt;Color&gt; &lt;Info&gt;&lt;/Info&gt; &lt;Buttons&gt;&lt;/Buttons&gt; &lt;/Color&gt; &lt;/&gt; )&#125;export default Home// info.jsimport React, &#123;useContext&#125; from &apos;react&apos;import &#123;ColorContext&#125; from &apos;./color&apos;function Info() &#123; const &#123;color&#125; = useContext(ColorContext) return ( &lt;&gt; &lt;h1 style=&#123;&#123;color&#125;&#125;&gt;当前的颜色是&#123;color&#125;&lt;/h1&gt; &lt;/&gt; )&#125;export default Info// buttons.jsimport React, &#123;useContext&#125; from &apos;react&apos;import &#123;UPDATE_COLOR, ColorContext&#125; from &apos;./color&apos;function Buttons() &#123; // dispatch是在共享状态里面的 const &#123;dispatch&#125; = useContext(ColorContext) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: UPDATE_COLOR, color: &apos;red&apos;&#125;)&#125;&#125;&gt;点击变为红色&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: UPDATE_COLOR, color: &apos;blue&apos;&#125;)&#125;&#125;&gt;点击变为蓝色&lt;/button&gt; &lt;/&gt; )&#125;export default Buttons// data.jsimport React, &#123;createContext, useReducer&#125; from &apos;react&apos;// 数据共享export const ColorContext = createContext(&#123;&#125;)export const UPDATE_COLOR = &apos;update_color&apos;function reducer(state, action) &#123; switch(action.type) &#123; case UPDATE_COLOR: return action.color default: return state &#125;&#125;export const Color = (props) =&gt; &#123; const [color, dispatch] = useReducer(reducer, &apos;blue&apos;) return ( &lt;ColorContext.Provider value=&#123;&#123;color, dispatch&#125;&#125;&gt; &#123;/* 保证内部所有的组件都可以使用传递的值 */&#125; &#123;props.children&#125; &lt;/ColorContext.Provider&gt; )&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-hooks","slug":"react-hooks","permalink":"http://yoursite.com/tags/react-hooks/"}]},{"title":"react-next","slug":"react-next","date":"2019-09-21T01:25:45.000Z","updated":"2019-09-21T01:27:32.138Z","comments":true,"path":"2019/09/21/react-next/","link":"","permalink":"http://yoursite.com/2019/09/21/react-next/","excerpt":"","text":"SPA 单一页面ian，首屏加载过慢 不能seo(对seo不友好) next.js SSR 服务端渲染 自带数据同步 带有丰富的插件(自己形成了生态) 配置灵活 项目搭建方式一 create-next-app npx create-next-app demo 方式二 yarn add react react-dom next 脚本命令配置:123&quot;dev&quot;: &quot;next&quot;,&quot;build&quot;: &quot;next build&quot;,&quot;start&quot;: &quot;next start&quot; 路由 会根据在pages下面写的路径来自动生成路由 Link标签控制跳转 Router.push 编程式跳转 使用query传递参数以及参数的接收 import {withRouter} from ‘next/router’ router.query.arg 路由的钩子事件 绑定事件：Router.events.on(‘routeChangeStart’, (…arg) =&gt; {console.log(..arg)}) routeChangeStart routeChangeComplete beforeHistoryChange routeChangeError hashChangeStart hashChangeComplete 使用axios获取数据 只能在getInitialProps里面进行数据请求、 使用easy-mock模拟数据12345678910111213141516171819202122232425import Link from &apos;next/link&apos;import &#123;withRouter&#125; from &apos;next/router&apos;import axios from &apos;axios&apos;const Test = (&#123;router, list&#125;) =&gt; &#123; return ( &lt;&gt; &lt;h1&gt;这是test页面&lt;/h1&gt; &lt;h2&gt;&#123;router.query.name&#125;&lt;/h2&gt; &lt;h3&gt;&#123;list&#125;&lt;/h3&gt; &lt;Link href=&apos;/index&apos;&gt; &lt;a&gt;回到首页&lt;/a&gt; &lt;/Link&gt; &lt;/&gt; )&#125;Test.getInitialProps = async () =&gt; &#123; const promise = new Promise(resolve =&gt; &#123; axios(&apos;https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList&apos;).then(res =&gt; &#123; console.log(res) resolve(res.data.data) &#125;) &#125;) return await promise&#125;export default withRouter(Test) 如何编写样式12345678910111213141516171819202122import &#123;useState&#125; from &apos;react&apos;function TestColor() &#123; const [color, setColor] = useState(&apos;blue&apos;) const changeColor = () =&gt; &#123; setColor(color == &apos;blue&apos; ? &apos;red&apos; : &apos;blue&apos;) &#125; return ( &lt;&gt; &lt;div className=&apos;blue&apos; onClick=&#123;changeColor&#125;&gt;这是蓝色&lt;/div&gt; &lt;style jsx&gt; &#123; ` .blue &#123; color: $&#123;color&#125;; &#125; ` &#125; &lt;/style&gt; &lt;/&gt; )&#125;export default TestColor 模块懒加载一. 外部模块懒加载 1234const changeTime = async () =&gt; &#123; const moment = await import(&apos;moment&apos;) setTime(moment.default(Date.now()).format())&#125; 二. 自定义组件懒加载 import dynamic from ‘next/dynamic’ const Com = dynamic(import(‘./components/com’)) 利于SEO import Head from ‘next/head’ next中引入css yarn add @zeit/next-css 新建next.config.js12345const withCss = require(&apos;@zeit/next-css&apos;)if(typeof require !== &apos;undefined&apos;) &#123; require.extensions[&apos;.css&apos;] = file =&gt; &#123;&#125;&#125;module.exports = withCss(&#123;&#125;) next使用antd yarn add antd yarn add babel-plugin-import 按需加载 安装完成后，在项目根目录建立.babelrc文件，然后写入如下配置文件。 123456789101112&#123; &quot;presets&quot;:[&quot;next/babel&quot;], //Next.js的总配置文件，相当于继承了它本身的所有配置 &quot;plugins&quot;:[ //增加新的插件，这个插件就是让antd可以按需引入，包括CSS [ &quot;import&quot;, &#123; &quot;libraryName&quot;:&quot;antd&quot;, &quot;style&quot;:&quot;css&quot; &#125; ] ]&#125; 这样配置好了以后，webpack就不会默认把整个Ant Design的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。 next打包 其实Next.js大打包时非常简单的，只要一个命令就可以打包成功。但是当你使用了Ant Desgin后，在打包的时候会遇到一些坑。 在page目录下，新建一个_app.js文件，然后写入下面的代码123import App from &apos;next/app&apos;import &apos;antd/dist/antd.css&apos;export default App","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-next","slug":"react-next","permalink":"http://yoursite.com/tags/react-next/"}]},{"title":"fabric","slug":"fabric","date":"2019-09-18T14:23:35.000Z","updated":"2019-09-18T14:29:15.862Z","comments":true,"path":"2019/09/18/fabric/","link":"","permalink":"http://yoursite.com/2019/09/18/fabric/","excerpt":"","text":"初始fabric12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;can&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;https://cdn.bootcss.com/fabric.js/3.4.0/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;can&apos;) var rect = new fabric.Rect(&#123; left: 100, top: 100, fill: &apos;red&apos;, width: 100, height: 80 &#125;) canvas.add(rect) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 画不规则图形1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var path = new fabric.Path(&apos;M 0 0 L 200 100 L 170 200 z&apos;) path.set(&#123; left: 200, top: 300, fill: &apos;blue&apos; &#125;) canvas.add(path) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 画圆1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var circle = new fabric.Circle(&#123; left: 100, top: 100, radius: 50, strokWidth: 1, stroke: &apos;red&apos; &#125;) canvas.add(circle) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 渐变圆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var circle = new fabric.Circle(&#123; left: 100, top: 100, radius: 50, strokWidth: 1, stroke: &apos;red&apos; &#125;) // 从上到下渐变 // circle.setGradient(&apos;fill&apos;, &#123; // x1: 0, // y1: 0, // x2: 0, // y2: circle.height, // colorStops: &#123; // 0: &apos;#f00&apos;, // 1: &apos;#ccc&apos; // &#125; // &#125;) // 从左到右渐变 circle.setGradient(&apos;fill&apos;, &#123; x1: 0, y1: 0, x2: circle.width, y2: 0, colorStops: &#123; 0: &apos;#00f&apos;, 1: &apos;#0f0&apos; &#125; &#125;) canvas.add(circle) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 让图形动起来1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var rect = new fabric.Rect(&#123; top: 100, left: 200, width: 200, height: 80, fill: &apos;red&apos; &#125;) rect.animate(&apos;left&apos;, 500, &#123; onChange: canvas.renderAll.bind(canvas), duration: 2000, easing: fabric.util.ease.easeOutBounce &#125;) canvas.add(rect) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件监听1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) // mouse: down ,move, up, after:render 画布重新渲染执行， selected var rect = new fabric.Rect(&#123; left: 100, top: 100, width: 100, height: 200, fill: &apos;red&apos; &#125;) rect.on(&apos;selected&apos;, function(options) &#123; console.log(&apos;选择了圆形&apos;, options) &#125;) canvas.add(rect) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图像过滤器123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) fabric.Image.fromURL(&apos;./lion.jpg&apos;, function(img) &#123; var filter = new fabric.Image.filters.Brightness(&#123; brightness: 0.1 &#125;); var sepia = new fabric.Image.filters.Sepia() // 增加过滤器效果 img.filters.push( filter, sepia ) // new fabric.Image.filters.Brightness(&#123;brightness: 10&#125;) // 应用过滤器 canvas.renderAll.bind(canvas) img.applyFilters() canvas.add(img) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文本编辑12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var text = new fabric.Text(&apos;hello world, 2019-09-18&apos;, &#123; left: 100, top: 100, fontFamily: &apos;Comic Sans&apos;, fontSize: 20 &#125;) canvas.add(text) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 颜色转换1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var color1 = new fabric.Color(&apos;#f00&apos;) var color2 = new fabric.Color(&apos;#ccc&apos;) var color3 = new fabric.Color(&apos;rgb(123,123,123)&apos;) var color4 = new fabric.Color(&apos;#999&apos;) console.log(color1.toRgb()) // 转成rgb console.log(color3.toHex()) // 转成16进制 var color5 = color2.overlayWith(color4).toHex() console.log(color5) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 正方形、圆形、三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; #can &#123; background-color: #fff; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width=&quot;800&quot; height=&quot;800&quot; id=&quot;can&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;can&apos;) var rect = new fabric.Rect(&#123; left: 100, top: 100, fill: &apos;pink&apos;, width: 100, height: 100 &#125;) var circle = new fabric.Circle(&#123; radius: 60, left: 200, top: 200, fill: &apos;blue&apos; &#125;) var triangle = new fabric.Triangle(&#123; left: 300, top: 300, fill: &apos;purple&apos;, width: 100, height: 150 &#125;) canvas.add(rect) canvas.add(circle) canvas.add(triangle) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; canvas插入图片-上123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; #canvas &#123; background-color: #fff; border: 1px solid red; &#125; #code &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;img src=&quot;./code.jpg&quot; id=&quot;code&quot; alt=&quot;&quot;&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var code = document.getElementById(&apos;code&apos;) var img = new fabric.Image(code, &#123; left: 100, top: 200, width: 100, height: 100 &#125;) canvas.add(img) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; canvas插入图片-下1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; #canvas &#123; background-color: #fff; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) fabric.Image.fromURL(&apos;./code.jpg&apos;, function(oimg) &#123; oimg.scale(0.6) oimg.left = 100 oimg.top = 200 canvas.add(oimg) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"fabric","slug":"fabric","permalink":"http://yoursite.com/tags/fabric/"}]},{"title":"nuxt","slug":"nuxt","date":"2019-09-13T02:04:25.000Z","updated":"2019-09-13T05:19:01.052Z","comments":true,"path":"2019/09/13/nuxt/","link":"","permalink":"http://yoursite.com/2019/09/13/nuxt/","excerpt":"","text":"背景 一个通用的vue框架 常用来做ssr ssr：在服务器端把vue的文件直接渲染为html返回给浏览器 对seo支持的非常好，比spa打开速度快一点 spa对seo是不友好的 新闻、博客、电影(需要搜索引擎提供流量的这种站点)这种网站必须要用ssr 什么是服务端渲染?后端先读取数据库，拿到数据，将数据和页面进行拼装成html文件，最后将完整的html页面返回给浏览器 什么是客户端渲染?数据由浏览器通过ajax向后台拿到数据，通过js将数据填充到dom元素上最终展示到网页中 前后端渲染对比 服务端渲染会消耗更多的服务端资源(CPU、内存) 客户端渲染可以将静态资源部署到cdn上，实现高并发 服务端渲染对seo更好(因为seo不能分析js文件，只能分析html结构的文件) 环境配置 npx create-nuxt-app projectName npm run dev 开启项目 目录结构和配置文件基本标签 nuxt-link _是动态路由的标志 默认模板 app.html 这样在每一个页面上都会引入app.html的内容 默认布局异步请求 asyncData asyncData() {return axios.get(url).then(res =&gt; {info: res.data}) // 自动把info写入到data中} async asyncData() {let {data} = await axios get(url)return {info: data}} 静态资源文件引用和打包生产 ~ npm run generate // 打包 安装npm i -g live-server 输入live-server启动","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"http://yoursite.com/tags/nuxt/"}]},{"title":"web安全","slug":"web安全","date":"2019-09-03T13:51:12.000Z","updated":"2019-09-03T15:55:38.836Z","comments":true,"path":"2019/09/03/web安全/","link":"","permalink":"http://yoursite.com/2019/09/03/web安全/","excerpt":"","text":"常见web攻击方式 XSS-反射型 跨站脚本攻击 反射型xss(恶意的url)，一次性的，由用户发起 chrome内置了一些xss过滤器，可以防止大部分反射型xss攻击 firefox安全性不如chrome 特点：用户手动触发，危害小，不持久 XSS-存储型 黑客将恶意脚本代码上传(比如通过评论，存入到对方服务器) 当客户端重新使用数据时，服务器会返回恶意代码，再次执行 特点时持久，不需要用户触发，危害更大 DOM-base XSS 用户打开一个恶意的链接 浏览器在dom解析的时候直接使用恶意数据 innerHTML、document.write… payload 实现xss攻击的恶意脚本就叫做payload xss钓鱼–通过xss向网页注入钓鱼链接，引导用户访问 通过payload拿到用户的sessionId后，就可以伪造成用户，进行操作 因为sessionId是唯一标识–后台识别客户 用户登陆后，后台会返回一个sessionId存储在客户端的cookie中 以后客户端每次请求都会把该cookie带上请求后端 所以cookie泄露会有很大风险 如何防御xss 设置cookie的httpOnly属性 这样在客户端就不能通过document.cookie获取到cookie 但是不能根本解决 永远不要相信前端的过滤，后台一定要进行过滤 设置白名单 设置黑名单 在标签里面、在属性上、在url地址、在函数参数传参写入时再次进行一层htmlEncode过滤 URL编码 encodeURI编码url的不对&amp;等保留字与特殊字符编码 encodeURIComponent用来编码传递参数的以及&amp;特殊符号 对一个get url的参数处理往往是二者一起使用 CSRF 跨站请求伪造 用户A登陆银行网站，登陆成功后拿到cookie 黑客诱导A登陆他的钓鱼网站 在钓鱼网站的内部内置了一个iframe，设置width、height分别为0，链接到一个transfer页面 transfer页面模拟用户A发请求转账到指定账户，因为这时候因为A并没有成功退出，所以他的cookie仍然有效，可以作为登陆凭证 防御CSRF svg-captcha // nodejs生成验证码 给用户一个验证码，但是影响用户体验 通过请求头referer判断是否是自己的站点，不可靠 参数伪造token，最主流的防御CSRF token 一次性的 用户不知情 XSS+CSRF=蠕虫DDOS攻击 分布式拒绝服务 黑客控制大量肉鸡向目标主机发送非正常请求，导致其消耗资源不能为合法用户的访问提供正常服务 防止DDOS 验证码 限制一个IP请求频率 增加机器增加服务器带宽 设置自己的业务为分布式服务，防止单点攻击 提高服务器负载能力","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"encrypt","slug":"encrypt","date":"2019-09-01T08:10:05.000Z","updated":"2019-09-01T08:21:43.719Z","comments":true,"path":"2019/09/01/encrypt/","link":"","permalink":"http://yoursite.com/2019/09/01/encrypt/","excerpt":"","text":"常见的前端加密库 crypto-js sjcl md5 sha1哈希加密 base64","categories":[],"tags":[{"name":"前端加密","slug":"前端加密","permalink":"http://yoursite.com/tags/前端加密/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"canvas","slug":"canvas","date":"2019-09-01T07:11:25.000Z","updated":"2019-09-01T07:38:59.854Z","comments":true,"path":"2019/09/01/canvas/","link":"","permalink":"http://yoursite.com/2019/09/01/canvas/","excerpt":"","text":"简介 HTML5新标签 本身不具备绘画功能 是一个矩形区域的画布 拥有多种绘制图形图像的方法 应用领域 游戏 广告 可视化数据 设置宽高 设置宽度和高度，通过属性设置，不要通过css设置 对于一个canvas标签来说，使用的时候一定要设置width和height属性，否则绘制的图形有问题 兼容性 IE9才支持 不支持会认为是div 兼容性写法1234&lt;canvas&gt; ie9以上才支持canvas，请升级浏览器 &lt;!-- flash --&gt;&lt;/canvas&gt; 步骤 拿到canvas标签 拿到上下文 绘制 常用方法 moveTo // 移动画笔到指定位置，不设置，没有位置 lineTo // 画线 stroke // 描边 closePath // 路径闭合 fill // 填充 常用属性 strokeStyle // 设置描边颜色 lineWidth // 线宽 fillStyle // 设置填充颜色 (a)12345var a = function() &#123; console.log(1)&#125;var b = (a) // b = f() &#123;console.log(1)&#125;b() // 1 绘制表格","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"yarn","slug":"yarn","date":"2019-08-29T13:39:30.000Z","updated":"2019-08-29T15:03:43.214Z","comments":true,"path":"2019/08/29/yarn/","link":"","permalink":"http://yoursite.com/2019/08/29/yarn/","excerpt":"","text":"带着问题学yarn？ yarn是什么？ yarn有什么优点？ yarn可以做什么？ 什么是一个package？ 什么是一个包管理器？ 公共包仓库是什么？ 为什么需要包管理器？ package会进行缓存 npm i yarn -g yarn -V yarn init // 初始化一个package.json包 yarn add yarn.lock // 存放各种包的信息 yarn upgrade webpack // 升级包 yarn cache ls // 查看本地安装了哪些缓存包 yarn cache dir // 查看package装在了本地什么路径 yarn cache clean // 清空本地缓存包 yarn add 已经缓存在本地的包 –offline // 离线安装 yarn install / yarn i / yarn // 安装项目依赖 dependences // 代码真正需要在浏览器上跑起来需要的一些依赖 devDependencies // 开发时需要的依赖 yarn remove [package] // 删除包 yarn install –production(prod) // 不会安装在devDependencies yarn publish // publish a package to a package manager, the same as npm publish yarn config yarn config set registry registry.npm.taobao.org // 设置yarn安装源，提升安装包的时候的速度 yarn info [package] // 查看包的信息，可以时远程的包 yarn global add webpack // 把webpack安装在全局 yarn 不推荐把依赖包安装在全局，不清晰，在其他机器很难保证项目可以正确运行，放在package.json更加清晰明确 yarn self-upate // yarn的自我更新 yarn why [package] // 帮助寻找项目依赖,告诉我们为什么需要依赖 yarn check // 检查包的完整性 yarn run example：create-dir：mkdir demo rm-dir：rm -rf demo yarn global ls // 查看全局安装的包","categories":[{"name":"包管理工具","slug":"包管理工具","permalink":"http://yoursite.com/categories/包管理工具/"}],"tags":[{"name":"包管理工具","slug":"包管理工具","permalink":"http://yoursite.com/tags/包管理工具/"}]},{"title":"dart","slug":"dart","date":"2019-08-25T13:57:11.000Z","updated":"2019-08-29T15:03:23.779Z","comments":true,"path":"2019/08/25/dart/","link":"","permalink":"http://yoursite.com/2019/08/25/dart/","excerpt":"","text":"环境安装 http://www.gekorm.com/dart-windows/ 安装dart sdk vscode开发 vscode 安装dart、code runner扩展插件 Google开发 被flutter带火 2011年诞生 类型 dart是一个强大的脚本语言 定义变量不指定类型，会自动推断，不能赋与其推断类型不一致的类型 String int dart存在类型校验 变量命名规则 字母、数字、下划线、$组成 区分大小写 不能以数字开头 dart常量 const 定义一个常量，编译时常量，一旦赋值不能修改 final 同样也是定义一个常量，但是比const强大，运行时常量，且属于惰性赋值 数据类型 三单(双)引号定义字符串，可以换行写字符串，单双引号则不行，只能写单行字符串 字符串拼接 $ + String int bool [] new List(),add,下标从0开始，集合类型 new List() 对象属性必须加引号 new Map()[“name”] = ‘hello wolrd’ is 类型判断 运算符 ??, example: b??=20 // 如果b为空的话就把20赋值给b 类型转换 Number to String，toString() String to Number，int.parse(str),double.parse() try{}catch(err){} string.isEmpty() // 判断字符串是否为空 number.isNaN() 集合类型 List List list = [] length isEmpty isNotEmpty reversed // 逆转 toList() // 转为List集合 add() // 相当于push，一次加一个 addAll([‘test’, ‘hello’]) // 拼接数组 indexOf // 获取索引值，查不到返回-1 remove(value) removeAt(index) fillRange() insert() insertAll(1, [‘hello’, ‘world’]) join() // 转为字符串 split() // 字符串转为List数组 Set 去重 new Set() add() 函数与方法 首字母小写，小驼峰 返回值类型 函数名() {函数体; return 返回值} 定义一个带可选参数的方法，String print(String username, [int age, String sex]) return “姓名:$username—年龄:$age” 定义一个命名参数的方法：String test(String name, {int age, String sex = ‘male’}) 类与对象 OOP，面向对象的三个基本特征–封装、继承、多态 类由属性和方法组成 所有东西都是对象，都是继承自object dart是一门使用类和单继承的面向对象，所有对象都是类的实例 构造方法/函数在程序一运行(实例化)的时候就会执行 dart里面构造函数可以写多个 Dart和其他面向OOP的语言不一样，没有public、private、protected这些访问修饰符，但是我们可以使用 _ 定义私有的属性和方法，然后还得抽离成一个文件才会生效 num get 方法名 // 计算属性 set 方法名(value) dart的抽象类 定义一个Animal类，并且要求他的子类必须实现他的eat方法 抽象类是一个标准，对子类的一个约束 抽象类有多个方法时子类必须要全部实现 抽象类里面可以有普通方法 抽象类不能直接实例化 多态 父类定义一个方法不去实现，让继承他的子类去实现它，每一个子类有不同的表现 官方表态：允许将子类类型的指针赋值给父类类型的指针，同一个函数的调用会有不同的执行效果，也就是说子类的实例赋值给父类的引用 接口 dart中没有interface关键字 抽象类会被作为接口被实现 定义一个DB库 支持mysql mongodb mssql，这三个类中都有同样的方法 接口就是约定，一种规范 通过implements 一个类实现多个接口 implements， 逗号隔开类名 实现所有方法和属性 mixins 新特性 with 和继承有点相似 作为mixins的类只能继承自Object，不能继承其他类 作为mixins的类不能有构造函数 mixins的类型就是其超类的子类型 泛型 传入什么类型，返回什么类型 12345678T getData&lt;T&gt;(T value) &#123; return value&#125;getData&lt;String&gt;(&apos;tet&apos;) // String给了T// 下面这种写法就不会对返回值类型进行校验getData&lt;T&gt;(T value) &#123; return value&#125; 泛型接口 demo 实现数据缓存的功能：有文件缓存、内存缓存、 定义一个泛型接口。约束实现他的子类必须有geyByKey(key)和setByKey(key, value) 要求setByKey的时候value的类型和实例化子类的时候指定的类型一致 解决代码重用 库 自定义 内置 import ‘dart:io’ import ‘dart:math’ pub async是让方法变成异步 await是等待异步方法执行完成 从下面网站中找到我们想要的库： https://pub.dev/packages https://pub.flutter-io.cn/packages https://pub.dartlang.org/flutter/ pubspec.lock pub get // 安装依赖 import ‘’ show getAge; // 从库中只引入getAge方法 import ‘’ as xxx; // 起个别名，解决冲突 import ‘’ hide getName; // 隐藏getName","categories":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/categories/Dart/"}],"tags":[{"name":"like C","slug":"like-C","permalink":"http://yoursite.com/tags/like-C/"}]},{"title":"Hello World --- Robin LEI","slug":"hello-world","date":"2019-08-24T08:05:11.966Z","updated":"2019-08-24T10:04:16.507Z","comments":true,"path":"2019/08/24/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}