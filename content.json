{"meta":{"title":"Robin LEI","subtitle":"用代码改变世界，因为喜欢所以热爱!","description":null,"author":"Robin LEI","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-29T14:55:41.000Z","updated":"2019-08-29T14:56:45.662Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-29T14:55:28.000Z","updated":"2019-08-29T14:56:01.156Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js","slug":"js","date":"2019-10-11T14:04:05.000Z","updated":"2019-10-14T15:10:38.126Z","comments":true,"path":"2019/10/11/js/","link":"","permalink":"http://yoursite.com/2019/10/11/js/","excerpt":"","text":"数据类型 基本数据类型 Number、String、Boolean、Null、Undefined、Symbol 基本数据类型存储在栈内存中 引用数据类型 除了上述几种，剩下的都是引用数据类型 Array Object Function RegExp Date 引用数据类型存储在堆内存中 类型检测 typeof 经常用来检测一个变量是不是基础数据类型 不能用来检测引用数据类型 检测 null，[]，/\\d+/，{}，new Date()都是object instanceof 检测一个构造函数的prototype属性是否存在于另一个要检测对象的原型链上 比如 A instanceof B，就是要检测B.prototype是否存在于A对象的原型链上 判断继承或者实例属于哪一个类型的时候比使用typeof更好用 不能检测字面量方式创建的基本数据类型 不能检测null和undefined Object.prototype.toString.call() cooke、session、localStorage localStorage 存储的数据是永久性的，除非用户手动删除，否则浏览器关闭后数据还是存在的 其作用域是限定在文档源级别的，所谓的文档源是指通过协议、主机名、端口号来确定的 同源的文档间共享localStorage sessionStorage 关闭标签页，session清空 关闭浏览器，session清空 二者的区别在于存储的有效期和作用域的不同，也就是说数据可以存储多长时间以及谁拥有数据的访问权 cookie 默认的有效期很短暂，只能持续在web浏览器的会话期间，一旦用户关闭浏览器，cookie数据就会丢失 关闭标签页，cookie不会丢失 有的浏览器不允许保存超过300个cookie 单个cookie保存的数据不能超过4kb null和undefined null是JavaScript语言的关键字 变量没有初始化、数组根据越界索引获取元素、对象属性不存在、函数没有返回值、没有提供函数实参的形参，这时候返回undefined JavaScript权威指南：你或许认为undefined是表示系统级的，出乎意料的错误，null表示正常的意料之中，当给一个变量赋值或者给一个函数传参时，使用null更好 函数的prototype 每一个函数都有一个prototype属性，默认指向一个空object对象(实例对象)(原型对象)(但是Object不满足)，空对象是指没有我们的属性 原型对象有一个constructor属性，指向其构造函数(函数对象) 原型对象上的方法是给实例对象用的 typeof Fn.prototype === ‘object’ // true 函数对象是在函数定义的时候创建 function Fn() {} // this.prototype = {} new Fn() // this.proto = Fn.prototype 任何函数，不管是内置函数还是自定义的函数，都是new Function的实例，保活它本身(Function也是Function的实例) Object的原型对象是原型链的尽头，因为Object.prototype.proto === null 显示原型 每个function都有一个prototype，就是显示原型(属性) Fn.prototype指向一个空对象，这个空对象是Object的实例 代码一执行，Object对象就已经存在 隐式原型 每一个实例对象都有一个proto，称为隐式原型(属性) 隐式原型的值就是等于其构造函数显示原型的值 原型继承 构造函数的实例对象自动拥有构造函数原型对象上的属性(方法) 利用的就是原型链 原型链属性 读取对象的属性时，会自动的到原型链上查找 设置对象的属性时，不会查找原型链，如果当前对象没有此属性，直接添加此属性并且设置值 方法一般定义再原型上，属性一般通过构造函数定义再对象本身 instanceof A instanceof B 如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false A是实例对象 Object.prototype是原型链的终点 1234567Object instanceof FunctionObject instanceof ObejctFunction instanceof FunctionFunction instanceof Obejctfunction Foo() &#123;&#125;Object instanceof Foo function Object() {}是new Function产生的 function Foo() {} . proto 指向Function.prototype 图解原型链 图解1 图解2 图解3 测试题1234567891011121314151617181920212223var A = function() &#123;&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n: 2, m: 3&#125;var c = new A()console.log(b.n, b.m, c.n, c.m)var F = function() &#123;&#125;Object.prototype.a = function() &#123; console.log(&apos;a()&apos;)&#125;Function.prototype.b = function() &#123; console.log(&apos;b()&apos;)&#125;var f = new F()f.a()f.b()F.a()F.b()","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"vue","slug":"vue","date":"2019-10-07T03:03:33.000Z","updated":"2019-10-11T13:29:19.045Z","comments":true,"path":"2019/10/07/vue/","link":"","permalink":"http://yoursite.com/2019/10/07/vue/","excerpt":"","text":"说说你对SPA单页面的理解？ single-page-application，只在页面初次渲染时加载HTML、JavaScript、CSS 优点：用户体验好–&gt;无刷新加载页面，网站整体速度变快，避免了不必要得跳转和重复的渲染–&gt;减轻了服务器端的压力，前后端架构更加清晰，前端负责交互逻辑，后端负责处理数据 缺点：首屏加载可能比较慢，不利于SEO–&gt;因为所有的内容都在一个页面中动态的显示 v-if and v-show v-if是真正意义上的dom的显示与隐藏，适用于不需要频繁地切换条件的场景–&gt;因为减少切换dom显示与隐藏的开销 v-show是样式display上的显示与隐藏，会带来渲染上的开销，适用于频繁改变条件的场景 class与style如何动态绑定? class 对象语法 :class12- 数组语法 + ```&lt;div v-bind:class=[isBox ? &apos;box&apos; : &apos;&apos;, isHasItem]&gt;&lt;/div&gt; &#123;isHasItem: 'item'&#125;```1232. style - 对象语法 + ```&lt;div :style=&#123;color: isColor, fontSize: fontSize&#125;&gt;&lt;/div&gt; &#123;isColor: 'red', fontSize: '20px'&#125;```12- 数组语法 + ```&lt;div :style=[Color, Size]&gt;&lt;/div&gt; &#123;Color: &#123;color: 'red'&#125;, Size: &#123;fontSize: '20px'&#125;&#125;```12345678910111213141516171819202122232425262728### 如何理解Vue的单向数据流?1. 父组件通过props把数据传递给子组件，当父组件的props更新时，子组件也会自动更新2. 但是，反之如果子组件修改父组件传递过来的props是不被允许的，因为这会导致其它使用同一props的子组件发生紊乱3. 有两种情况我们往往想要去修改父组件传递来的props - 子组件把父组件的props当作局部数据来使用，解决办法：在定义一个变量去把props作为初始值 - 子组件想要把父组件的props加以修缮变成自己想要的数据时，解决办法：使用computed计算属性4. JS中数组和对象是引用数据类型，当props是数组或者对象时，子组件如果修改了它，会导致父组件的状态发生改变，解决办法：子组件可以深拷贝一份父组件的props### Vue中父组件和子组件的生命周期钩子函数的执行顺序?1. 加载渲染过程 - beforeCreate(父组件)-&gt;created(父组件)-&gt;beforeMount(父组件)-&gt;beforeCreate(子组件)-&gt;created(子组件)-&gt;beforeMount(子组件)-&gt;mounted(子组件)-&gt;mounted(父组件)2. 子组件更新 - beforeUpdate(父组件)-&gt;beforeUpdate(子组件)-&gt;updated(子组件)-&gt;updated(父组件)3. 父组件更新 - beforeUpdate(父组件)-&gt;updated(父组件)4. 组件销毁 - beforeDestroy(父组件)-&gt;beforeDestroy(子组件)-&gt;destroyed(子组件)-&gt;destroyed(父组件)### 在哪个生命周期钩子函数内去调用异步API?1. 要想能够去调用api，首先组件内部的data必须要先创建完成2. 在created，beforeMount，mounted中data均已经创建完成，但是推荐在created中调用3. 因为可以减少loading等待时间4. vue的nuxt.js SSR不支持beforeMount和mounted，放在created中更加有利于项目的移植### 父组件监听子组件的生命周期?1. 在某些情况下，子组件如果挂载完成之后，父组件需要做一些业务逻辑，那么就需要去监听子组件的mounted钩子函数2. 第一种方法 // Parent.vue&lt;Child @mounted=’do’&gt;do() {} // Child.vuemounted() { this.$emit(‘mounted’) // 子组件需要手动触发} 13. 第二种方法,@hook也可以监听created和updated等钩子函数 // Parent.vue&lt;Child @hook:mounted=’do’&gt;do() {} // Child.vuemounted() { } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849### Vue项目的性能优化1. 代码层面 - v-if、v-show的使用场景 - computed、watch的使用场景 - v-for加key - 长列表的渲染时使用Object.freeze()冻结一个对象，对象被冻结以后，只能读，加入某个组件单纯的只负责显示，没有任何其他操作，这时我们就不想再对其使用Object.defineProperty()，层面数据劫持，这可以减少组件初始化的时间 - 事件使用之后要进行销毁 - 图片的懒加载 - 路由的懒加载2. webpack - 图片压缩 - 提取公共代码 - 优化sourceMap3. web层面 - 服务端开启gzip压缩 - 某些资源使用CDN - 浏览器缓存机制### Vue的SSR1. vue在客户端渲染标签为html片段的工作交给了服务端，服务端直接返回给客户端一个已经渲染完成的html片段2. 优点：对SEO更友好，之前页面的内容是通过Ajax获取到的，Ajax是异步的，搜索引擎的爬虫不会去等待异步完成之后再去爬取页面内容，所以爬虫爬不到数据，但是采用了SSR服务端渲染，爬虫爬取的时候页面已经存在了html和数据，不容易出现首页白屏3. 缺点：增加了服务端的压力### Vuex1. state 存储数据状态的2. getter 获取store中数据的3. mutation 修改store中state的状态，同步4. action 异步，先通过commit触发mutation再去修改状态5. module 把store拆分，往往在大型项目中使用### Vue组件通信1. props/$emit 父子组件通信2. event bus 父子、兄弟、隔代组件通信3. ref/$parent/$children 父子组件通信4. vuex 所有的都适用，但是最好在大一点的项目中使用比较合适5. $attrs/$listeners 隔代组件6. provide/inject 适用于隔代组件### 为什么Vue中组件的data必须是一个函数function1. vue组件中的data必须是一个function，且需要返回一个&#123;&#125;2. vue实例中的data只需要是一个对象即可3. 因为组件是可以复用的，每复用一次，就会产生一个实例，多个实例之间共享一个对象，因为他们是同一个对象的引用，这样在一个页面中改变组件的值，会影响其他页面的同一个组件，如果组件返回一个&#123;&#125;，这个多个实例指向不同的数据对象4. 而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。### keep-alive1. 避免组件的不必要的再次渲染，常常配合路由meta一起使用2. 配合动态组件使用时，可以保持组件的之前的状态3. 两大属性include、exclude // include表示只要name属性为A，B的组件才会进行缓存，注意这里的name时组件的名称// exclude表述除了组件C以外的都会被缓存 1234567891011### vue-router的钩子函数1. 导航钩子其实就是指路由的生命周期函数2. 导航的钩子分为全局的和局部的还有组件的3. 全局的有beforeEach、afterEach4. 单个路由局部的钩子函数有beforeEnter5. 单个组件内的钩子函数有beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave### 插槽1. 默认插槽(匿名插槽)】 ```&lt;slot&gt;&lt;/slot&gt; 具名插槽 123456// 插槽&lt;slot name=&apos;test&apos;&gt;&lt;/slot&gt;// 使用&lt;div slot=&apos;test&apos;&gt; 这是具名插槽&lt;/div&gt; 作用域插槽 1234567891011121314151617181920212223// Parent.vue&lt;Child&gt; &lt;template slot-scope=&quot;list(这个名字随便起)&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list.list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt;&lt;/Child&gt;// 如果不使用作用域插槽提供的数据，这个时候作用域插槽摇身一变变为匿名插槽&lt;Child&gt; &lt;p&gt;你好，我就不使用你的数据&lt;/p&gt;&lt;/Child&gt;// Child.vue&lt;div&gt; &lt;slot :data=&quot;list&quot;&gt;&lt;/slot&gt;&lt;/div&gt;data() &#123; return &#123; list: [1,2,3] &#125;&#125; $nextTick vue中并不是数据更新之后，dom立即更新 nextTick()在下次dom更新结束之后，执行的回调函数，可以获取更新后的dom12345// 修改数据this.list = [1,2,3]this.$nextTick(() =&gt; &#123; // 获取更新后的dom&#125;) MVC model、view、controller 当用户输入信息先到达controller，controller判断如果这个信息不需要调取接口，则会自己处理后直接把信息返回给view(用户) 如果controller判断需要调取后端api，这个时候会把信息传递到model层，在model层去调取接口，处理数据后，由model层把信息传递给view层 view层和model层也是可以直接交互的，如果view层传出的信息不涉及到业务处理，也可以直接和model层直接交互 MVC最大的缺点就是反馈信息不及时，由此诞生了MVVM MVVM 与MVC一起，都属于一种架构模式 由三部分构成，model、view、viewModel model与view没有联系，view和viewModel以及model与viewModel之间是相互联系的 viewModel就像是一个中间件，处理所有的业务逻辑，使得model和view更加专注于做自己的事情 采用MVVM模式，使得代码的解耦性更强，缺点是不利于调式，无法第一时间判断错误来自view层还是model层 虚拟dom 采用虚拟dom提升了效率，本质上优化了diff算法 使用JS对象去创建真实dom 在dom更新的时候，采用新旧dom对比，找出差异部分(也是一个JS对象)，然后更新为真实dom 虚拟dom更加适合批量操作dom React vs Vue 相同点 采用组件化开发，使得代码的复用性更高 都有自己的服务端渲染(SSR) 都有虚拟dom 都可以通过props在父子组件之间进行通信 都是靠数据驱动 不同点 vue中的数据绑定是双向的，界面于数据之间 react是单向数据流，只能由数据到界面 写法不同，vue采用的是模板，react使用的是jsx(js的扩展) vue没有state的概念，相对应的是data，修改data数据比较随意 react有state概念，且修改数据必须通过setState vue-cli的生成的项目目录和各个文件的作用 build // webpack的配置文件 build.js // webpack的打包配置文件 check-version.js // 检查node、npm版本 utils.js // 项目的构建工具 webpack.base.conf.js // webpack的公共配置 webpack.dev.conf.js // 开发配置 webpack.prod.conf.js // 生产配置 config // 变量的配置文件 index.js // 公共变量配置 dev.env.js // 开发环境变量配置 prod.env.js // 生产环境变量配置 node_modules // 包管理工具下载的依赖 src // 项目的源代码 assets // 静态资源存放，如图片 components // 项目的组件存放 router // 路由 App.vue // 项目的入口 main.js // 程序的入口 test // 测试文件 e2e unit .babelrc // 把es6代码进行编译配置文件 .eslintrc // eslint的plugins、extends文件 .eslintignore // 忽视eslint的配置文件 .gitignore // 提交代码时忽视的文件 .postcssrc // post css配置文件 .editorconfig // 编辑器的配置文件 package.json // 项目的信息、依赖的包 index.html // 项目的首页 static // 静态数据(资源)存放，比如json数据","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"url","slug":"url","date":"2019-10-06T10:44:46.000Z","updated":"2019-10-06T10:45:31.116Z","comments":true,"path":"2019/10/06/url/","link":"","permalink":"http://yoursite.com/2019/10/06/url/","excerpt":"","text":"输入一个url地址到网页出来发生了什么? DNS解析 先查看浏览器缓存有没有 如果没有查看本机hosts文件，有没有域名对应的IP地址 如果没有，查看路由器缓存有没有 如果没有，查看运营提供商有没有与之对应的IP地址 如果没有，继续查找至根域名解析服务器，从顶级域名.com开始进行递归搜索 根据TCP协议，建立连接 拿到IP地址后，根据TCP协议，建立连接(TCP的三次握手) 浏览器(客户端)(syn=1，用来建立连接，询问服务端，我能和你建立连接吗?我的序列号seq=x，如果同意，就回复ack=x+1)发送消息给服务端 服务端发送消息(ack=x+1,syn=1,seq=y,询问浏览器，我能和你建立连接吗?如果同意，回复ack=y+1)给客户端 浏览器发送消息(ack=y+1)给服务端，告诉说自己已经收到了 发送请求报文 浏览器开始发送请求报文信息 接受响应报文 服务端接受请求之后，发送响应报文给浏览器 根据渲染树绘制页面 浏览器在接受的过程中，如果遇到了不同的标记，就采用不同的方式去解析 如果遇到了HTML标记，浏览器就会采用html解析器去解析成DOM树 如果遇到了css/style/link标记，浏览器就会调用css解析器去解析为CSSOM树 如果遇到了script标记，就会调用js解析器解析执行js代码 将DOM树和CSSOM树合并为render tree(渲染树) 根据渲染树计算位置，计算出每个节点的位置信息，渲染到屏幕上 断开连接(TCP四次挥手) 第一次挥手，浏览器告诉服务器，我东西发送完了(请求报文)，你准备关闭吧 第二次挥手，服务器告诉浏览器，我东西接收完了(接受请求报文)我准备关闭了，你也准备吧 第三次挥手，服务器告诉浏览器，我东西发送完了(响应报文)，你准备关闭吧 第四次挥手，浏览器发送到服务器，告诉说自己东西接收(响应报文)完了，你准备关闭吧","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"react","slug":"react","date":"2019-10-06T08:34:20.000Z","updated":"2019-10-06T08:34:44.028Z","comments":true,"path":"2019/10/06/react/","link":"","permalink":"http://yoursite.com/2019/10/06/react/","excerpt":"","text":"React中keys的作用是什么? 虚拟dom的唯一标识 可以提升效率 不建议使用index索引作为key，比如一个数组更新前：[1,2,3,4],索引依次是0，1，2，3 更新后数组为：[4,3,2,1],索引为0，1，2，3，这个时候react会检查每一个索引对应的值都不一样，这个时候就会把原有的删除重新创建，但是如果我们使用id作为标识，会发现这个时候只是元素的位置发生了移动，没有必要去重新删除在创建 React有什么特点? 单向数据流 可以进行服务端渲染 使用的是虚拟DOM而不是真实DOM 为什么浏览器无法读取JSX? 浏览器只能处理JavaScript对象，但是不能读取JS对象中的JSX 浏览器为了可以识别JSX语法，需要使用像babel这样的JSX转换器将JSX文件转为JavaScript对象，然后再将其传给浏览器 生命周期函数 加载阶段 constructor componentWillMount render componentDidMount 更新阶段 shouldComponentUpdate componentWillUpdate render componentDidUpdate 销毁阶段 componentWillUnmount 父组件的props属性值发生改变的时候 componentWillReceiveProps react生命周期(16.8+) 挂载阶段 constructor // 初始化state getDerevedStateFromProps // 接受到新的属性想要去修改state render componentDidMount 更新阶段 getDerivedStateFromProps // 在挂载和更新阶段都可能会调用 shouldComponentUpdate render getSnapsshotBeforeUpdate componentDidUpdate 卸载阶段 componentWillUnmount 注意，16.8+废弃了(并未删除)以下几个生命周期函数 componentWillMount componentWillReceiveProps componentWillUpdate setState同步异步 异步 12345678910// 方法一setState((prvState, props) =&gt; &#123; // 第一个参数是修改前的state // 第二个参数是修改前的props&#125;, () =&gt; &#123; // 拿到执行后的最新结果&#125;)// 方法二setState(&#123;&#125;) 在componentDidMount中调用setState之后，还会再次调用render方法进行渲染 react组件通信 父组件调用子组件方法 在子组件中定义方法fn 在调用子组件的标签中，加入ref属性，标记为child 在父组件的方法中，通过this.refs.child.childMethods() 兄弟 redux redux工作流 redux有以下几个部分组成 react component action(creators) store reducers 可以这样去分析redux这几个部分 react component去图书馆借书的人 action比做借书人说的话 store就是图书馆管理员 reducers是记录图书信息的手册 使用流程 先要创建store，使用createStore createStore需要一个参数，这个参数是reducers，因此需要创建reducers，export defult (state = stateDefault, action) =&gt; {} 在组件中使用时，需要先引入store，使用getState()获取store中state的数据 如果组件本身要想触发一个action，修改store中的数据，需要在组件中创建一个action，action = {type: ‘’, data: ‘’}，通过dispatch(action)通知store store本身不做处理，会自动把传过来的action和prevState转发到reducers上，reducer处理完毕后，把处理完成的结果也就是新的state数据返回给store 组件要想及时获取最新的state，需要订阅，store.subscribe(this.handleFunc)，当拿到新的state时会先触发this.handleFunc函数 区分有状态组件和无状态组件 函数方式声明的组件是静态的，是不能动的，没有状态的 使用class类定义的组件可以自定义组件状态对象 state render方法指的是组件如何渲染，只能返回一个react元素，而且只能返回一个react元素 react合成事件和原生事件 合成事件：react并不是将click直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面 当事件触发的时候，使用统一的事件分发处理函数dispatchEvent将指定函数执行 什么是受控组件和非受控组件 比如 value123456789102. ```&lt;input /&gt;```这种没有value限制，随便输入3. 显然react中受控组件更好，因为react靠数据驱动，受数据控制### 什么是状态提升1. 在每个组件中可以通过setState修改自己组件状态，但是如何去修改其他的组件的状态?2. 每一个组件维护自己的state，难以修改别的组件的state3. 状态提升：就是将组件的状态提升到父组件中，然后组件共享父组件的状态### 高阶组件1. 本质上是一个函数 function HocComponent(wrappedComponent) { return class extends Component { render() { // 属性代理 return &lt;wrappedComponent {…this.props} /&gt; } }} HocComponent(参数是一个组件(class)名称) 122. 提高代码复用性3. 通过ref获取组件实例 class Text extends React.Component { say() { } render() { return ( &lt;div&gt;hello&lt;/div&gt; ) }}function HocComponent(wrappedComponent) { return class extends Component { proc(instance) { instance.say() } render() { return &lt;wrappedComponent {…this.props} ref={this.proc} /&gt; } }}const NewComponent = HocComponent(Text) 1234### ref1. 图片加载完后，获取图片的宽度和高度2. 建议这样使用 componentDidMount() { // 拿到this.elem} {this.elem = div}}> ```","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"宏任务、微任务","slug":"宏任务微任务","date":"2019-10-06T07:52:59.000Z","updated":"2019-10-06T07:56:13.392Z","comments":true,"path":"2019/10/06/宏任务微任务/","link":"","permalink":"http://yoursite.com/2019/10/06/宏任务微任务/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 一道题简单谈宏任务和微任务 --&gt; &lt;!-- 宏任务 --&gt; &lt;!-- JS是单线程的，JS code在js主线程上执行的 --&gt; &lt;!-- 如果执行的过程中遇到了定时器，点击事件，ajax异步请求等，这个时候主线程先不执行它们，他们会进入事件队列中等待 --&gt; &lt;!-- 主线程执行完代码后，会立即去任务队列中查看有没有任务等待执行，如果有则会把他们提到主线程上执行 --&gt; &lt;!-- JS引擎规定了，setTimeout，setInterval，Ajax，click都属于宏任务 --&gt; &lt;!-- 规定了new Promise().then(callback)，proceed.nextTick()属于微任务 --&gt; &lt;!-- 宏任务就是指宏任务队列中的任务 --&gt; &lt;!-- 微任务就是指微任务队列中的任务 --&gt; &lt;!-- 宏任务队列不止一个，但是第一个宏任务队列只有一个任务等待主线程执行，当第一个宏任务队列全部执行完毕后，会立即查看是否存在微任务队列 --&gt; &lt;!-- 如果存在微任务队列，就会先把微任务队列中的任务全部执行完毕，注意微任务队列和宏任务队列有所不同，微任务队列只能有一个 --&gt; &lt;!-- 当微任务的任务全部执行完毕后，再去查看是否有其他的宏任务队列，如果有则继续执行 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log(&apos;start&apos;); // 1 setTimeout(function() &#123; console.log(&apos;setTimeout&apos;); // 5 &#125;, 0) new Promise((resolve, reject) =&gt; &#123; for(let i = 0; i &lt; 10; i++) &#123; console.log(i); // 2 &#125; resolve(&apos;resolve&apos;) &#125;).then(data =&gt; &#123; console.log(data); // 4 &#125;) console.log(&apos;end&apos;); // 3 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"mobx","slug":"mobx","date":"2019-10-02T11:45:00.000Z","updated":"2019-10-02T11:45:22.335Z","comments":true,"path":"2019/10/02/mobx/","link":"","permalink":"http://yoursite.com/2019/10/02/mobx/","excerpt":"","text":"redux connect()是将state装饰为props，从而使得state变化视图也变化 MobX 任何事情因为state变化而变化的他就应该变化而且是自动的 npm i mobx -S, npm i mobx-react -S 我们一定要深刻理解，react中一个组件，只因为两个事情的变化而变化 组件的state变化(必须用setState来改变state的值) 传入到组件的props变化 react的props本身是只读的 使用了Proxy代理对象 使用修饰器 es6新增的语法，使用@开头 修饰一个对象 123&#123; @observable a: 100&#125; 修饰一个类 1234@observerclass App extends Components &#123;&#125; 需要安装如下插件 1// babel-plugin-transform-decorators-legacy 受修饰器的影响，修饰器只能修饰类，所以还得安装一个插件 1npm i babel-plugin-transform-class-properties -S observable and observe 前者表示可被观察的，来自mobx，类中的属性 后者表示观察者，来自mobx-react，组件类 类必须要实例化，传入组件当作props @action@computed","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"mobx","slug":"mobx","permalink":"http://yoursite.com/tags/mobx/"}]},{"title":"eventloop","slug":"eventloop","date":"2019-10-01T09:49:54.000Z","updated":"2019-10-01T09:53:25.745Z","comments":true,"path":"2019/10/01/eventloop/","link":"","permalink":"http://yoursite.com/2019/10/01/eventloop/","excerpt":"","text":"event loop JavaScript的代码按照队列的形式一个一个的执行，在同一时间只能执行一段代码 JS是单线程的，这一点是由JS本身的用途决定的，假如当一个线程在添加dom，另一个线程去删除dom，那么此时UI线程就会懵圈了，不知道听谁的 JS作为浏览器脚本存在，负责用户交互和操作dom JS代码如果长时间执行，会导致进程阻塞，进而冻结用户浏览器界面 JS的任务分为同步任务和异步任务 同步任务由JS主线程直接执行 异步任务JS主线程会先执行一部分，比如点击事件，等用户点击时在执行剩余部分 JS主线程会从任务队列中一个一个去执行 浏览器的线程机制 JS执行线程：执行JS代码 UI线程：执行UI渲染，和JS执行线程互斥 JS事件循环线程","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"函数与变量","slug":"函数与变量","date":"2019-09-28T04:16:22.000Z","updated":"2019-09-28T04:17:52.677Z","comments":true,"path":"2019/09/28/函数与变量/","link":"","permalink":"http://yoursite.com/2019/09/28/函数与变量/","excerpt":"","text":"变量提升机制 JavaScript的引擎的工作方式是，先解析代码，获取所有被声明的变量，在去一行行的执行代码，这造成的结果就是所有变量的声明语句，都会被提升到代码的头部，JavaScript的这种读取变量的机制就叫做变量提升。 所有被var声明的语句都会被提升到代码的头部 如果不使用var关键字声明变量，则变量是全局变量，按照正常书写顺序去执行 一等公民 可以像简单值一样赋值、传参、返回 函数名提升 JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会将变量声明一样，被提升到代码头部 12qiuhe(1,2)function qiuhe(a,b) &#123;console.log(a+b)&#125; // 3 只有function声明的函数会发生函数名提升，而如果通过赋值语句写的函数则不会 12qiuhe(1,2)var qiuhe = function(a,b) &#123;console.log(a+b)&#125; // qiuhe is not a function 函数的作用域链 函数的变量值的查找方式：优先在本层(所在函数的作用域)中查找，当本层中没有的时候，向上一层查找，如果找到返回，否则继续向上查找 当在全局作用域内也没有找到，则此变量没有被定义 函数体的变量提升，与全局作用域一样，函数作用域内部也会产生”变量提升”现象，var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部 eval 将字符串当作语句执行 123var str = &apos;var num = 100;&apos;;eval(str);console.log(num); instanceof类型检测 typeof用来检测基本数据类型，但是如果是引用数据类型，则需要使用instanceof操作符 instanceof用于判断一个变量是否是某个对象的实例","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"闭包","slug":"闭包","date":"2019-09-27T15:17:08.000Z","updated":"2019-09-27T15:18:01.965Z","comments":true,"path":"2019/09/27/闭包/","link":"","permalink":"http://yoursite.com/2019/09/27/闭包/","excerpt":"","text":"闭包 获取函数的局部变量 让局部变量始终生存在内存中，避免被垃圾回收 闭包中的this都是window 不能滥用闭包，因为变量不能得到及时的释放，可能会造成内存溢出 不安全，因为在外部可以改变函数内部的局部变量值 闭包是一个能够读取函数内部变量的函数 同时，闭包也是一座桥梁–连接了函数的外部和内部 作用域 全局 函数（局部） js语言的特殊之处在函数内部能够直接读取全局变量，反之不行 如何在函数外部读取函数内部变量 不使用var声明的变量是全局变量 但是只有函数执行后才有值 一个没有返回值的函数其返回值是undefined 闭包demo1. 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;aaaa&lt;/li&gt; &lt;li&gt;bbbb&lt;/li&gt; &lt;li&gt;cccc&lt;/li&gt; &lt;li&gt;dddd&lt;/li&gt; &lt;li&gt;eeee&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; var ul = document.getElementById(&apos;ul&apos;) for(var i = 0; i &lt; ul.children.length; i++) &#123; (function(i) &#123; ul.children[i].onclick = function() &#123; alert(i) &#125; &#125;)(i) &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fun(n, o) &#123; console.log(o) return &#123; fun: function(m) &#123; return fun(m, n) &#125; &#125; &#125; // var a = fun(0) // a.fun(1) // a.fun(2) // a.fun(3) // var b = fun(0).fun(1).fun(2).fun(3) var c = fun(0).fun(1) c.fun(2) c.fun(3) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}]},{"title":"HTML","slug":"html","date":"2019-09-27T12:32:00.000Z","updated":"2019-10-07T03:06:18.587Z","comments":true,"path":"2019/09/27/html/","link":"","permalink":"http://yoursite.com/2019/09/27/html/","excerpt":"","text":"浏览器内核 trident: 1997开始在ie使用 blink:Google,2013年之前用的是webkit webkit:safari gecko:Firefox presto:opera servo:mozilla和三星达成协议,准备开发下一代浏览器内核servo DTD 主要是为了告诉浏览器采用哪种模式(或规范)解析页面 web浏览器布局引擎有三种模式: 怪异模式,quirks mode 混杂模式,almost standards mode,准标准模式 标准模式,full standards mode 如果不写dtd,浏览器就会按照自己的方式去解析页面,因为不同的浏览器有自己不同的解析方式,所以会导致同一个页面在不同浏览器出现不一致的样式,这称之为quirks mode 如果写了dtd声明,浏览器就会按照W3C的标准规范去解析页面 在IE6之前,是不存在dtd模式的,之前的布局都是采用旧的一种布局方式,在IE6之后,出现了dtd模式,此时为了兼容之前的网页,就在顶部加了来区分 src与href src会替换当前元素 href会在当前文档和引用资源之间确立联系 src串行加载资源,会把指向的资源下载到当前文档内,同时会阻塞当前文档的正常渲染,例如js脚本,image,frame href是并行加载 link与@import link没有兼容性,属于xhtml与html标签,不仅可以对css引入,还可以定义rss(聚合内容),还支持使用JavaScript来操作dom控制元素样式 @import存在兼容性,在CSS2.1后引入,只是单纯的css标签,不支持js操作 block formatting context 可以看作一个沙箱 不论内部元素如何变动均不会改变外部布局 根元素body,position:absolute/fixed,float:left/right,display:inline-block/table会触发BFC 内部盒子会垂直排列,两个盒子的间距由margin决定,但是margin会发生合并,可以设置overflow解决 BFC可以解决外边距重叠问题 BFC可以去除浮动 html与xhtml html对开发者比较宽容,写法上没有xhtml严格 xhtml不支持标签大写,也不允许大小写混合写 xhtml标签上只允许使用双引号 xhtml不支持target=_blank,可以设置rel=”external”配合JavaScript使用 opacity和rgba() opacity会穿透 rgba不会 如何让一个元素水平垂直居中 使用position:relative;position:absolute;transform:translate(-50%) 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; position: relative; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 使用display:flex; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; display: flex; justify-content: center; align-items: center; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; position: absolute; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; top:0;right:0;bottom:0;left:0;margin:auto; 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; position: relative; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; position: absolute; /* 遮罩,充满整个父级元素大小 */ top: 0; right: 0; bottom: 0; left: 0; /* 会使得上下,左右平分剩余空间 */ margin: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; display:table-cell;text-align:center;vertical-align:middle; 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .outer-box &#123; width: 600px; height: 600px; border: 1px solid red; display: table-cell; text-align: center; vertical-align: middle; &#125; .inner-box &#123; width: 300px; height: 300px; border: 1px solid blue; display: inline-block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;outer-box&quot;&gt; &lt;div class=&quot;inner-box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; H5C3 H5新特性:增强型表单控件,语义化标签,拖拽,地理定位,canvas,websocket,webworker,localstorage,音频/视频 C3新特性:rgba,text-shadow,box-shadow,border-radius,border-image,border-color,transform,transition,animation 说说css选择器以及这些选择器得优先级 !important 内联1000 ID选择器0100 类选择器\\属性选择器\\伪类选择器0010 元素\\关系\\伪元素选择器0001 通配符0000 盒模型 盒模型 box-sizing: content-box; // 盒模型为内容区域的宽度和高度 box-sizing: border-box; // 盒模型为内容区域+padding+border 实现左侧固定,右侧自适应的布局 利用float+margin 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; height: 100vh; &#125; #box &gt; div &#123; height: 100%; &#125; .box-left &#123; width: 200px; background-color: #FF0000; float: left; &#125; .box-right &#123; margin-left: 200px; background-color: aqua; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;box-left&quot;&gt; left &lt;/div&gt; &lt;div class=&quot;box-right&quot;&gt; right &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 利用calc+float 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; height: 100vh; &#125; #box &gt; div &#123; height: 100%; &#125; .box-left &#123; width: 200px; background-color: #FF0000; float: left; &#125; .box-right &#123; width: calc(100% - 200px); float: right; background-color: aqua; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;box-left&quot;&gt; left &lt;/div&gt; &lt;div class=&quot;box-right&quot;&gt; right &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 利用float+overflow（触发BFC） 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; height: 100vh; &#125; #box &gt; div &#123; height: 100%; &#125; .box-left &#123; width: 200px; background-color: #FF0000; float: left; &#125; .box-right &#123; overflow: hidden; background-color: aqua; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div class=&quot;box-left&quot;&gt; left &lt;/div&gt; &lt;div class=&quot;box-right&quot;&gt; right &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; display：flex； 如何避免回流与重绘1.","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"前端模块化","slug":"module","date":"2019-09-25T14:42:33.000Z","updated":"2019-09-25T14:58:50.052Z","comments":true,"path":"2019/09/25/module/","link":"","permalink":"http://yoursite.com/2019/09/25/module/","excerpt":"","text":"背景 最早的就是单纯的写代码(非常容易污染全局环境) 然后演化到了使用命名空间的形式去简单包装，但是本质上也还是对象，仍然不安全 然后演化到了使用匿名闭包(IIFE模式) 在增强到引入依赖 全局函数模式 将不同的功能封装在不同的全局函数里 非常容易覆盖，不管是函数名还是变量 namespace 仍然可以操作对象，修改数据 匿名函数自调用 想让外面拿到数据，就得通过window暴露 IIFE 引入依赖 现代模块实现的基石1234567(function(window, $) &#123; let name = &apos;test&apos; function foo() &#123; console.log(name) &#125; $(&apos;body&apos;).css(&apos;background&apos;: &apos;red&apos;)&#125;)(window, jQuery) commonjs nodejs就是基于这种 每一个文件都是一个模块 模块分为第三方模块和自定义模块 module.exports和exports.xxx都可以导出，但是本质上导出的是exports 在浏览器端如果需要使用commonjs需要引入browserify浏览器打包工具 执行browser js/src/index.js -o js/dist/bundle.js AMD 专门用在浏览器端 异步加载模块 模块分为无依赖模块和有依赖模块 需要引入require.js库 在没有引入AMD概念之前，前端js模块之间的引入十分恶心，对于错综复杂的项目依赖之间容易搞混，会导致页面上引入过多的script标签，而script标签又会导致页面请求次数过多，影响性能 jquery内置支持AMD CMD 依赖sea.js库 借鉴了commonJS和CMD 可以同步加载模块也可以异步加载模块 ES6 export导出 import导入 在浏览器不支持es6语法的时候，需要引入babel转换工具，需要安装： 12npm i babel-cli browserify -gnpm i babel-preset-es2015 -S 注意babel只能编译文件，不能新建文件夹","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"模块化","slug":"模块化","permalink":"http://yoursite.com/tags/模块化/"}]},{"title":"mock","slug":"mock","date":"2019-09-24T13:10:50.000Z","updated":"2019-09-24T13:11:17.821Z","comments":true,"path":"2019/09/24/mock/","link":"","permalink":"http://yoursite.com/2019/09/24/mock/","excerpt":"","text":"背景 快速构建restful api，完成前后端分离开发 前后端分离开发方案mock 和后端约定好接口的标准 后端开始开发接口 前端通过假数据方式模拟一个后端接口 使用http-server搭建静态资源服务器、live-server第三方mock工具 mock.js(无法持久化数据) json-server 使用mock http://mockjs.com 引入mock.js后，会有一个全局对象Mock Mock.mock(‘/users’, ‘get’, {hello: ‘world’})1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;mock&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Mock.mock(&apos;/details&apos;, &apos;get&apos;, Mock.mock(&#123; &quot;name|1-10&quot;: &quot;*&quot;, &quot;age|1-20&quot;: 1 &#125;)) $.get(&apos;/details&apos;, (res) =&gt; &#123; console.log(&apos;res&apos;, res) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; json-server GitHub json文件中每一个名字都是一个资源 restful 面向资源编程 资源指的就是一类数据 最重要的是如何去表示一个资源(地址即资源)","categories":[],"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-hooks","slug":"react-hooks","date":"2019-09-22T13:39:19.000Z","updated":"2019-09-22T13:39:48.893Z","comments":true,"path":"2019/09/22/react-hooks/","link":"","permalink":"http://yoursite.com/2019/09/22/react-hooks/","excerpt":"","text":"背景 用函数替代了类 方法即组件 useState 不能存在于if语句中 react自带的一个hook函数，用来声明状态变量 const [count, setCount] = useState(0) 该函数接受的参数是状态的初始值，返回一个数组，数组的第0位是当前的初始值，第1位是改变状态值的方法函数 useEffect 等于componentDidMount和componentDidUpdate 在组件挂载和更新时触发 组件销毁 componentWillUnmount 使用useEffect，当组件销毁时执行1234567891011121314151617181920function Index() &#123; useEffect(() =&gt; &#123; console.log(&apos;组件挂载时执行&apos;) return () =&gt; &#123; console.log(&apos;组件卸载时执行&apos;) &#125; &#125;) return (&lt;h1&gt;这是Index页面&lt;h1&gt;)&#125;// 但是当我们每次改变数据时，会打印console.log(&apos;组件挂载时执行&apos;)，解决办法如下：// 需要借助于useEffect的返回函数的第二个参数，第二个参数可以写入很多状态对应的变量，意思是当状态值发生改变时才进行解绑，但是我们如何传入一个[]作为第二个参数时，就是当组件将被销毁时才进行解绑function Index() &#123; useEffect(()=&gt;&#123; console.log(&apos;组件挂载时执行&apos;) return ()=&gt;&#123; console.log(&apos;组件卸载时执行&apos;) &#125; &#125;,[]) return (&lt;h1&gt;这是Index页面&lt;h1&gt;)&#125; useContext 解决父子组件传值 可以实现跨层级的组件传值问题 可以访问全局状态，避免数据一层层的传递，和redux类似(状态的全局化，并且可以统一管理)123456789101112131415161718192021222324252627282930import React, &#123;createContext,useContext,useState&#125; from &apos;react&apos;const CountContext = createContext()// 子组件function Children() &#123; let count = useContext(CountContext) return ( &lt;&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;h3&gt;&#123;count&#125;&lt;/h3&gt; &lt;/&gt; )&#125;function Parent() &#123; const [count, setCount] = useState(0) return ( &lt;&gt; &lt;h1&gt;这是parent组件&lt;/h1&gt; &lt;h2&gt;次数:&#123;count&#125;&lt;/h2&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count+1)&#125;&#125;&gt;点击使得次数增加&lt;/button&gt; &lt;CountContext.Provider value=&#123;count&#125;&gt; &lt;Children /&gt; &lt;/CountContext.Provider&gt; &lt;/&gt; )&#125;export default Parent useReducer 通过action的传递，更新复杂逻辑的状态 控制业务逻辑1234567891011121314151617181920212223242526import React, &#123;useReducer&#125; from &apos;react&apos;function UseReducer() &#123; const [count, dispatch] = useReducer((state, action) =&gt; &#123; switch(action) &#123; case &apos;add&apos;: return state + 1 break case &apos;minus&apos;: return state - 1 break default: return state break &#125; &#125;, 0) return ( &lt;&gt; &lt;h1&gt;这是第几次&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&apos;add&apos;)&#125;&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&apos;minus&apos;)&#125;&#125;&gt;minus&lt;/button&gt; &lt;/&gt; )&#125;export default UseReducer useMemo解决子组件重复执行的问题 常常用于缓存变量123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父组件import React, &#123; useState &#125; from &apos;react&apos;;import UseMemoChild from &apos;./useMemoChild&apos;function UseMemo() &#123; const [A, setA] = useState(&apos;这是A&apos;) const [B, setB] = useState(&apos;这是B&apos;) return ( &lt;&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123;setA(new Date().getTime()+&apos;点击了A&apos;)&#125;&#125;&gt;点击A&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;setB(new Date().valueOf()+&apos;点击了B&apos;)&#125;&#125;&gt;点击B&lt;/button&gt; &lt;UseMemoChild isA=&#123;A&#125; &gt;&#123;B&#125;&lt;/UseMemoChild&gt; &lt;/&gt; )&#125;export default UseMemo// 子组件import React, &#123;useMemo&#125; from &apos;react&apos;;function UseMemoChild(&#123;isA, children&#125;) &#123; function handleAMethods(isA) &#123; console.log(`执行了A的处理方法:$&#123;isA&#125;`) return `执行了A的处理方法:$&#123;isA&#125;` &#125; // 优化前 // const handleA = handleAMethods(isA) // 优化后 const handleA = useMemo(() =&gt; &#123; return handleAMethods(isA) &#125;, [isA]) return ( &lt;&gt; &lt;h2&gt;这是子组件页面&lt;/h2&gt; &lt;h3&gt;接收到父组件数据A：&#123;handleA&#125;&lt;/h3&gt; &lt;h3&gt;接收到父组件数据B：&#123;children&#125;&lt;/h3&gt; &lt;/&gt; )&#125;export default UseMemoChild useRef 获取dom元素 一般不推荐此操作 useCallback 缓存方法 提升性能，避免不必要的问题出现 优化react hooks程序性能 使用function的形式编写组件，使得我们丢了shouldComponentUpdate这个生命周期函数 也就是我们没有办法在组件更新之前去控制这个组件是不是要重新渲染 在函数组件中，也没有了mount和update两个状态，这意味着函数组件的每一次执行都会执行内部的所有逻辑，就带来了非常大的性能损耗 使用useMemo和useCallback就可以解决这个性能问题 自定义hooks函数 自定义的hooks函数偏向于功能 组件偏向于界面和业务逻辑的实现 往往使用use开头命名，这样才能更好的区分组件和自定义hooks函数1234567891011121314151617181920212223242526272829import React, &#123;useState, useEffect, useCallback&#125; from &apos;react&apos;;function useWinSize() &#123; const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) const onResize = useCallback(() =&gt; &#123; setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) &#125;) useEffect(() =&gt; &#123; window.addEventListener(&apos;resize&apos;, onResize) return () =&gt; &#123; window.removeEventListener(&apos;resize&apos;, onResize) &#125; &#125;, []) return size&#125;function Hooks() &#123; const size = useWinSize() return ( &lt;&gt; &lt;h1&gt;当前的浏览器的尺寸大小是: &#123;size.width&#125; x &#123;size.height&#125;&lt;/h1&gt; &lt;/&gt; )&#125;export default Hooks demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// index.jsimport React from &apos;react&apos;import Info from &apos;./info&apos;import Buttons from &apos;./buttons&apos;import &#123;Color&#125; from &apos;./color&apos;function Home() &#123; return ( &lt;&gt; &lt;Color&gt; &lt;Info&gt;&lt;/Info&gt; &lt;Buttons&gt;&lt;/Buttons&gt; &lt;/Color&gt; &lt;/&gt; )&#125;export default Home// info.jsimport React, &#123;useContext&#125; from &apos;react&apos;import &#123;ColorContext&#125; from &apos;./color&apos;function Info() &#123; const &#123;color&#125; = useContext(ColorContext) return ( &lt;&gt; &lt;h1 style=&#123;&#123;color&#125;&#125;&gt;当前的颜色是&#123;color&#125;&lt;/h1&gt; &lt;/&gt; )&#125;export default Info// buttons.jsimport React, &#123;useContext&#125; from &apos;react&apos;import &#123;UPDATE_COLOR, ColorContext&#125; from &apos;./color&apos;function Buttons() &#123; // dispatch是在共享状态里面的 const &#123;dispatch&#125; = useContext(ColorContext) return ( &lt;&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: UPDATE_COLOR, color: &apos;red&apos;&#125;)&#125;&#125;&gt;点击变为红色&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123;dispatch(&#123;type: UPDATE_COLOR, color: &apos;blue&apos;&#125;)&#125;&#125;&gt;点击变为蓝色&lt;/button&gt; &lt;/&gt; )&#125;export default Buttons// data.jsimport React, &#123;createContext, useReducer&#125; from &apos;react&apos;// 数据共享export const ColorContext = createContext(&#123;&#125;)export const UPDATE_COLOR = &apos;update_color&apos;function reducer(state, action) &#123; switch(action.type) &#123; case UPDATE_COLOR: return action.color default: return state &#125;&#125;export const Color = (props) =&gt; &#123; const [color, dispatch] = useReducer(reducer, &apos;blue&apos;) return ( &lt;ColorContext.Provider value=&#123;&#123;color, dispatch&#125;&#125;&gt; &#123;/* 保证内部所有的组件都可以使用传递的值 */&#125; &#123;props.children&#125; &lt;/ColorContext.Provider&gt; )&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-hooks","slug":"react-hooks","permalink":"http://yoursite.com/tags/react-hooks/"}]},{"title":"react-next","slug":"react-next","date":"2019-09-21T01:25:45.000Z","updated":"2019-09-21T01:27:32.138Z","comments":true,"path":"2019/09/21/react-next/","link":"","permalink":"http://yoursite.com/2019/09/21/react-next/","excerpt":"","text":"SPA 单一页面ian，首屏加载过慢 不能seo(对seo不友好) next.js SSR 服务端渲染 自带数据同步 带有丰富的插件(自己形成了生态) 配置灵活 项目搭建方式一 create-next-app npx create-next-app demo 方式二 yarn add react react-dom next 脚本命令配置:123&quot;dev&quot;: &quot;next&quot;,&quot;build&quot;: &quot;next build&quot;,&quot;start&quot;: &quot;next start&quot; 路由 会根据在pages下面写的路径来自动生成路由 Link标签控制跳转 Router.push 编程式跳转 使用query传递参数以及参数的接收 import {withRouter} from ‘next/router’ router.query.arg 路由的钩子事件 绑定事件：Router.events.on(‘routeChangeStart’, (…arg) =&gt; {console.log(..arg)}) routeChangeStart routeChangeComplete beforeHistoryChange routeChangeError hashChangeStart hashChangeComplete 使用axios获取数据 只能在getInitialProps里面进行数据请求、 使用easy-mock模拟数据12345678910111213141516171819202122232425import Link from &apos;next/link&apos;import &#123;withRouter&#125; from &apos;next/router&apos;import axios from &apos;axios&apos;const Test = (&#123;router, list&#125;) =&gt; &#123; return ( &lt;&gt; &lt;h1&gt;这是test页面&lt;/h1&gt; &lt;h2&gt;&#123;router.query.name&#125;&lt;/h2&gt; &lt;h3&gt;&#123;list&#125;&lt;/h3&gt; &lt;Link href=&apos;/index&apos;&gt; &lt;a&gt;回到首页&lt;/a&gt; &lt;/Link&gt; &lt;/&gt; )&#125;Test.getInitialProps = async () =&gt; &#123; const promise = new Promise(resolve =&gt; &#123; axios(&apos;https://www.easy-mock.com/mock/5cfcce489dc7c36bd6da2c99/xiaojiejie/getList&apos;).then(res =&gt; &#123; console.log(res) resolve(res.data.data) &#125;) &#125;) return await promise&#125;export default withRouter(Test) 如何编写样式12345678910111213141516171819202122import &#123;useState&#125; from &apos;react&apos;function TestColor() &#123; const [color, setColor] = useState(&apos;blue&apos;) const changeColor = () =&gt; &#123; setColor(color == &apos;blue&apos; ? &apos;red&apos; : &apos;blue&apos;) &#125; return ( &lt;&gt; &lt;div className=&apos;blue&apos; onClick=&#123;changeColor&#125;&gt;这是蓝色&lt;/div&gt; &lt;style jsx&gt; &#123; ` .blue &#123; color: $&#123;color&#125;; &#125; ` &#125; &lt;/style&gt; &lt;/&gt; )&#125;export default TestColor 模块懒加载一. 外部模块懒加载 1234const changeTime = async () =&gt; &#123; const moment = await import(&apos;moment&apos;) setTime(moment.default(Date.now()).format())&#125; 二. 自定义组件懒加载 import dynamic from ‘next/dynamic’ const Com = dynamic(import(‘./components/com’)) 利于SEO import Head from ‘next/head’ next中引入css yarn add @zeit/next-css 新建next.config.js12345const withCss = require(&apos;@zeit/next-css&apos;)if(typeof require !== &apos;undefined&apos;) &#123; require.extensions[&apos;.css&apos;] = file =&gt; &#123;&#125;&#125;module.exports = withCss(&#123;&#125;) next使用antd yarn add antd yarn add babel-plugin-import 按需加载 安装完成后，在项目根目录建立.babelrc文件，然后写入如下配置文件。 123456789101112&#123; &quot;presets&quot;:[&quot;next/babel&quot;], //Next.js的总配置文件，相当于继承了它本身的所有配置 &quot;plugins&quot;:[ //增加新的插件，这个插件就是让antd可以按需引入，包括CSS [ &quot;import&quot;, &#123; &quot;libraryName&quot;:&quot;antd&quot;, &quot;style&quot;:&quot;css&quot; &#125; ] ]&#125; 这样配置好了以后，webpack就不会默认把整个Ant Design的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。 next打包 其实Next.js大打包时非常简单的，只要一个命令就可以打包成功。但是当你使用了Ant Desgin后，在打包的时候会遇到一些坑。 在page目录下，新建一个_app.js文件，然后写入下面的代码123import App from &apos;next/app&apos;import &apos;antd/dist/antd.css&apos;export default App","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-next","slug":"react-next","permalink":"http://yoursite.com/tags/react-next/"}]},{"title":"fabric","slug":"fabric","date":"2019-09-18T14:23:35.000Z","updated":"2019-09-18T14:29:15.862Z","comments":true,"path":"2019/09/18/fabric/","link":"","permalink":"http://yoursite.com/2019/09/18/fabric/","excerpt":"","text":"初始fabric12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;can&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;https://cdn.bootcss.com/fabric.js/3.4.0/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;can&apos;) var rect = new fabric.Rect(&#123; left: 100, top: 100, fill: &apos;red&apos;, width: 100, height: 80 &#125;) canvas.add(rect) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 画不规则图形1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var path = new fabric.Path(&apos;M 0 0 L 200 100 L 170 200 z&apos;) path.set(&#123; left: 200, top: 300, fill: &apos;blue&apos; &#125;) canvas.add(path) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 画圆1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var circle = new fabric.Circle(&#123; left: 100, top: 100, radius: 50, strokWidth: 1, stroke: &apos;red&apos; &#125;) canvas.add(circle) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 渐变圆1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var circle = new fabric.Circle(&#123; left: 100, top: 100, radius: 50, strokWidth: 1, stroke: &apos;red&apos; &#125;) // 从上到下渐变 // circle.setGradient(&apos;fill&apos;, &#123; // x1: 0, // y1: 0, // x2: 0, // y2: circle.height, // colorStops: &#123; // 0: &apos;#f00&apos;, // 1: &apos;#ccc&apos; // &#125; // &#125;) // 从左到右渐变 circle.setGradient(&apos;fill&apos;, &#123; x1: 0, y1: 0, x2: circle.width, y2: 0, colorStops: &#123; 0: &apos;#00f&apos;, 1: &apos;#0f0&apos; &#125; &#125;) canvas.add(circle) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 让图形动起来1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var rect = new fabric.Rect(&#123; top: 100, left: 200, width: 200, height: 80, fill: &apos;red&apos; &#125;) rect.animate(&apos;left&apos;, 500, &#123; onChange: canvas.renderAll.bind(canvas), duration: 2000, easing: fabric.util.ease.easeOutBounce &#125;) canvas.add(rect) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件监听1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) // mouse: down ,move, up, after:render 画布重新渲染执行， selected var rect = new fabric.Rect(&#123; left: 100, top: 100, width: 100, height: 200, fill: &apos;red&apos; &#125;) rect.on(&apos;selected&apos;, function(options) &#123; console.log(&apos;选择了圆形&apos;, options) &#125;) canvas.add(rect) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 图像过滤器123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) fabric.Image.fromURL(&apos;./lion.jpg&apos;, function(img) &#123; var filter = new fabric.Image.filters.Brightness(&#123; brightness: 0.1 &#125;); var sepia = new fabric.Image.filters.Sepia() // 增加过滤器效果 img.filters.push( filter, sepia ) // new fabric.Image.filters.Brightness(&#123;brightness: 10&#125;) // 应用过滤器 canvas.renderAll.bind(canvas) img.applyFilters() canvas.add(img) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文本编辑12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var text = new fabric.Text(&apos;hello world, 2019-09-18&apos;, &#123; left: 100, top: 100, fontFamily: &apos;Comic Sans&apos;, fontSize: 20 &#125;) canvas.add(text) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 颜色转换1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var color1 = new fabric.Color(&apos;#f00&apos;) var color2 = new fabric.Color(&apos;#ccc&apos;) var color3 = new fabric.Color(&apos;rgb(123,123,123)&apos;) var color4 = new fabric.Color(&apos;#999&apos;) console.log(color1.toRgb()) // 转成rgb console.log(color3.toHex()) // 转成16进制 var color5 = color2.overlayWith(color4).toHex() console.log(color5) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 正方形、圆形、三角形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; #can &#123; background-color: #fff; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width=&quot;800&quot; height=&quot;800&quot; id=&quot;can&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;can&apos;) var rect = new fabric.Rect(&#123; left: 100, top: 100, fill: &apos;pink&apos;, width: 100, height: 100 &#125;) var circle = new fabric.Circle(&#123; radius: 60, left: 200, top: 200, fill: &apos;blue&apos; &#125;) var triangle = new fabric.Triangle(&#123; left: 300, top: 300, fill: &apos;purple&apos;, width: 100, height: 150 &#125;) canvas.add(rect) canvas.add(circle) canvas.add(triangle) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; canvas插入图片-上123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; #canvas &#123; background-color: #fff; border: 1px solid red; &#125; #code &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;img src=&quot;./code.jpg&quot; id=&quot;code&quot; alt=&quot;&quot;&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) var code = document.getElementById(&apos;code&apos;) var img = new fabric.Image(code, &#123; left: 100, top: 200, width: 100, height: 100 &#125;) canvas.add(img) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; canvas插入图片-下1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; #canvas &#123; background-color: #fff; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;800&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./fabric/fabric.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var canvas = new fabric.Canvas(&apos;canvas&apos;) fabric.Image.fromURL(&apos;./code.jpg&apos;, function(oimg) &#123; oimg.scale(0.6) oimg.left = 100 oimg.top = 200 canvas.add(oimg) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"fabric","slug":"fabric","permalink":"http://yoursite.com/tags/fabric/"}]},{"title":"nuxt","slug":"nuxt","date":"2019-09-13T02:04:25.000Z","updated":"2019-09-13T05:19:01.052Z","comments":true,"path":"2019/09/13/nuxt/","link":"","permalink":"http://yoursite.com/2019/09/13/nuxt/","excerpt":"","text":"背景 一个通用的vue框架 常用来做ssr ssr：在服务器端把vue的文件直接渲染为html返回给浏览器 对seo支持的非常好，比spa打开速度快一点 spa对seo是不友好的 新闻、博客、电影(需要搜索引擎提供流量的这种站点)这种网站必须要用ssr 什么是服务端渲染?后端先读取数据库，拿到数据，将数据和页面进行拼装成html文件，最后将完整的html页面返回给浏览器 什么是客户端渲染?数据由浏览器通过ajax向后台拿到数据，通过js将数据填充到dom元素上最终展示到网页中 前后端渲染对比 服务端渲染会消耗更多的服务端资源(CPU、内存) 客户端渲染可以将静态资源部署到cdn上，实现高并发 服务端渲染对seo更好(因为seo不能分析js文件，只能分析html结构的文件) 环境配置 npx create-nuxt-app projectName npm run dev 开启项目 目录结构和配置文件基本标签 nuxt-link _是动态路由的标志 默认模板 app.html 这样在每一个页面上都会引入app.html的内容 默认布局异步请求 asyncData asyncData() {return axios.get(url).then(res =&gt; {info: res.data}) // 自动把info写入到data中} async asyncData() {let {data} = await axios get(url)return {info: data}} 静态资源文件引用和打包生产 ~ npm run generate // 打包 安装npm i -g live-server 输入live-server启动","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"nuxt","slug":"nuxt","permalink":"http://yoursite.com/tags/nuxt/"}]},{"title":"web安全","slug":"web安全","date":"2019-09-03T13:51:12.000Z","updated":"2019-09-03T15:55:38.836Z","comments":true,"path":"2019/09/03/web安全/","link":"","permalink":"http://yoursite.com/2019/09/03/web安全/","excerpt":"","text":"常见web攻击方式 XSS-反射型 跨站脚本攻击 反射型xss(恶意的url)，一次性的，由用户发起 chrome内置了一些xss过滤器，可以防止大部分反射型xss攻击 firefox安全性不如chrome 特点：用户手动触发，危害小，不持久 XSS-存储型 黑客将恶意脚本代码上传(比如通过评论，存入到对方服务器) 当客户端重新使用数据时，服务器会返回恶意代码，再次执行 特点时持久，不需要用户触发，危害更大 DOM-base XSS 用户打开一个恶意的链接 浏览器在dom解析的时候直接使用恶意数据 innerHTML、document.write… payload 实现xss攻击的恶意脚本就叫做payload xss钓鱼–通过xss向网页注入钓鱼链接，引导用户访问 通过payload拿到用户的sessionId后，就可以伪造成用户，进行操作 因为sessionId是唯一标识–后台识别客户 用户登陆后，后台会返回一个sessionId存储在客户端的cookie中 以后客户端每次请求都会把该cookie带上请求后端 所以cookie泄露会有很大风险 如何防御xss 设置cookie的httpOnly属性 这样在客户端就不能通过document.cookie获取到cookie 但是不能根本解决 永远不要相信前端的过滤，后台一定要进行过滤 设置白名单 设置黑名单 在标签里面、在属性上、在url地址、在函数参数传参写入时再次进行一层htmlEncode过滤 URL编码 encodeURI编码url的不对&amp;等保留字与特殊字符编码 encodeURIComponent用来编码传递参数的以及&amp;特殊符号 对一个get url的参数处理往往是二者一起使用 CSRF 跨站请求伪造 用户A登陆银行网站，登陆成功后拿到cookie 黑客诱导A登陆他的钓鱼网站 在钓鱼网站的内部内置了一个iframe，设置width、height分别为0，链接到一个transfer页面 transfer页面模拟用户A发请求转账到指定账户，因为这时候因为A并没有成功退出，所以他的cookie仍然有效，可以作为登陆凭证 防御CSRF svg-captcha // nodejs生成验证码 给用户一个验证码，但是影响用户体验 通过请求头referer判断是否是自己的站点，不可靠 参数伪造token，最主流的防御CSRF token 一次性的 用户不知情 XSS+CSRF=蠕虫DDOS攻击 分布式拒绝服务 黑客控制大量肉鸡向目标主机发送非正常请求，导致其消耗资源不能为合法用户的访问提供正常服务 防止DDOS 验证码 限制一个IP请求频率 增加机器增加服务器带宽 设置自己的业务为分布式服务，防止单点攻击 提高服务器负载能力","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"encrypt","slug":"encrypt","date":"2019-09-01T08:10:05.000Z","updated":"2019-09-01T08:21:43.719Z","comments":true,"path":"2019/09/01/encrypt/","link":"","permalink":"http://yoursite.com/2019/09/01/encrypt/","excerpt":"","text":"常见的前端加密库 crypto-js sjcl md5 sha1哈希加密 base64","categories":[],"tags":[{"name":"前端加密","slug":"前端加密","permalink":"http://yoursite.com/tags/前端加密/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"canvas","slug":"canvas","date":"2019-09-01T07:11:25.000Z","updated":"2019-09-01T07:38:59.854Z","comments":true,"path":"2019/09/01/canvas/","link":"","permalink":"http://yoursite.com/2019/09/01/canvas/","excerpt":"","text":"简介 HTML5新标签 本身不具备绘画功能 是一个矩形区域的画布 拥有多种绘制图形图像的方法 应用领域 游戏 广告 可视化数据 设置宽高 设置宽度和高度，通过属性设置，不要通过css设置 对于一个canvas标签来说，使用的时候一定要设置width和height属性，否则绘制的图形有问题 兼容性 IE9才支持 不支持会认为是div 兼容性写法1234&lt;canvas&gt; ie9以上才支持canvas，请升级浏览器 &lt;!-- flash --&gt;&lt;/canvas&gt; 步骤 拿到canvas标签 拿到上下文 绘制 常用方法 moveTo // 移动画笔到指定位置，不设置，没有位置 lineTo // 画线 stroke // 描边 closePath // 路径闭合 fill // 填充 常用属性 strokeStyle // 设置描边颜色 lineWidth // 线宽 fillStyle // 设置填充颜色 (a)12345var a = function() &#123; console.log(1)&#125;var b = (a) // b = f() &#123;console.log(1)&#125;b() // 1 绘制表格","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"yarn","slug":"yarn","date":"2019-08-29T13:39:30.000Z","updated":"2019-08-29T15:03:43.214Z","comments":true,"path":"2019/08/29/yarn/","link":"","permalink":"http://yoursite.com/2019/08/29/yarn/","excerpt":"","text":"带着问题学yarn？ yarn是什么？ yarn有什么优点？ yarn可以做什么？ 什么是一个package？ 什么是一个包管理器？ 公共包仓库是什么？ 为什么需要包管理器？ package会进行缓存 npm i yarn -g yarn -V yarn init // 初始化一个package.json包 yarn add yarn.lock // 存放各种包的信息 yarn upgrade webpack // 升级包 yarn cache ls // 查看本地安装了哪些缓存包 yarn cache dir // 查看package装在了本地什么路径 yarn cache clean // 清空本地缓存包 yarn add 已经缓存在本地的包 –offline // 离线安装 yarn install / yarn i / yarn // 安装项目依赖 dependences // 代码真正需要在浏览器上跑起来需要的一些依赖 devDependencies // 开发时需要的依赖 yarn remove [package] // 删除包 yarn install –production(prod) // 不会安装在devDependencies yarn publish // publish a package to a package manager, the same as npm publish yarn config yarn config set registry registry.npm.taobao.org // 设置yarn安装源，提升安装包的时候的速度 yarn info [package] // 查看包的信息，可以时远程的包 yarn global add webpack // 把webpack安装在全局 yarn 不推荐把依赖包安装在全局，不清晰，在其他机器很难保证项目可以正确运行，放在package.json更加清晰明确 yarn self-upate // yarn的自我更新 yarn why [package] // 帮助寻找项目依赖,告诉我们为什么需要依赖 yarn check // 检查包的完整性 yarn run example：create-dir：mkdir demo rm-dir：rm -rf demo yarn global ls // 查看全局安装的包","categories":[{"name":"包管理工具","slug":"包管理工具","permalink":"http://yoursite.com/categories/包管理工具/"}],"tags":[{"name":"包管理工具","slug":"包管理工具","permalink":"http://yoursite.com/tags/包管理工具/"}]},{"title":"dart","slug":"dart","date":"2019-08-25T13:57:11.000Z","updated":"2019-08-29T15:03:23.779Z","comments":true,"path":"2019/08/25/dart/","link":"","permalink":"http://yoursite.com/2019/08/25/dart/","excerpt":"","text":"环境安装 http://www.gekorm.com/dart-windows/ 安装dart sdk vscode开发 vscode 安装dart、code runner扩展插件 Google开发 被flutter带火 2011年诞生 类型 dart是一个强大的脚本语言 定义变量不指定类型，会自动推断，不能赋与其推断类型不一致的类型 String int dart存在类型校验 变量命名规则 字母、数字、下划线、$组成 区分大小写 不能以数字开头 dart常量 const 定义一个常量，编译时常量，一旦赋值不能修改 final 同样也是定义一个常量，但是比const强大，运行时常量，且属于惰性赋值 数据类型 三单(双)引号定义字符串，可以换行写字符串，单双引号则不行，只能写单行字符串 字符串拼接 $ + String int bool [] new List(),add,下标从0开始，集合类型 new List() 对象属性必须加引号 new Map()[“name”] = ‘hello wolrd’ is 类型判断 运算符 ??, example: b??=20 // 如果b为空的话就把20赋值给b 类型转换 Number to String，toString() String to Number，int.parse(str),double.parse() try{}catch(err){} string.isEmpty() // 判断字符串是否为空 number.isNaN() 集合类型 List List list = [] length isEmpty isNotEmpty reversed // 逆转 toList() // 转为List集合 add() // 相当于push，一次加一个 addAll([‘test’, ‘hello’]) // 拼接数组 indexOf // 获取索引值，查不到返回-1 remove(value) removeAt(index) fillRange() insert() insertAll(1, [‘hello’, ‘world’]) join() // 转为字符串 split() // 字符串转为List数组 Set 去重 new Set() add() 函数与方法 首字母小写，小驼峰 返回值类型 函数名() {函数体; return 返回值} 定义一个带可选参数的方法，String print(String username, [int age, String sex]) return “姓名:$username—年龄:$age” 定义一个命名参数的方法：String test(String name, {int age, String sex = ‘male’}) 类与对象 OOP，面向对象的三个基本特征–封装、继承、多态 类由属性和方法组成 所有东西都是对象，都是继承自object dart是一门使用类和单继承的面向对象，所有对象都是类的实例 构造方法/函数在程序一运行(实例化)的时候就会执行 dart里面构造函数可以写多个 Dart和其他面向OOP的语言不一样，没有public、private、protected这些访问修饰符，但是我们可以使用 _ 定义私有的属性和方法，然后还得抽离成一个文件才会生效 num get 方法名 // 计算属性 set 方法名(value) dart的抽象类 定义一个Animal类，并且要求他的子类必须实现他的eat方法 抽象类是一个标准，对子类的一个约束 抽象类有多个方法时子类必须要全部实现 抽象类里面可以有普通方法 抽象类不能直接实例化 多态 父类定义一个方法不去实现，让继承他的子类去实现它，每一个子类有不同的表现 官方表态：允许将子类类型的指针赋值给父类类型的指针，同一个函数的调用会有不同的执行效果，也就是说子类的实例赋值给父类的引用 接口 dart中没有interface关键字 抽象类会被作为接口被实现 定义一个DB库 支持mysql mongodb mssql，这三个类中都有同样的方法 接口就是约定，一种规范 通过implements 一个类实现多个接口 implements， 逗号隔开类名 实现所有方法和属性 mixins 新特性 with 和继承有点相似 作为mixins的类只能继承自Object，不能继承其他类 作为mixins的类不能有构造函数 mixins的类型就是其超类的子类型 泛型 传入什么类型，返回什么类型 12345678T getData&lt;T&gt;(T value) &#123; return value&#125;getData&lt;String&gt;(&apos;tet&apos;) // String给了T// 下面这种写法就不会对返回值类型进行校验getData&lt;T&gt;(T value) &#123; return value&#125; 泛型接口 demo 实现数据缓存的功能：有文件缓存、内存缓存、 定义一个泛型接口。约束实现他的子类必须有geyByKey(key)和setByKey(key, value) 要求setByKey的时候value的类型和实例化子类的时候指定的类型一致 解决代码重用 库 自定义 内置 import ‘dart:io’ import ‘dart:math’ pub async是让方法变成异步 await是等待异步方法执行完成 从下面网站中找到我们想要的库： https://pub.dev/packages https://pub.flutter-io.cn/packages https://pub.dartlang.org/flutter/ pubspec.lock pub get // 安装依赖 import ‘’ show getAge; // 从库中只引入getAge方法 import ‘’ as xxx; // 起个别名，解决冲突 import ‘’ hide getName; // 隐藏getName","categories":[{"name":"Dart","slug":"Dart","permalink":"http://yoursite.com/categories/Dart/"}],"tags":[{"name":"like C","slug":"like-C","permalink":"http://yoursite.com/tags/like-C/"}]},{"title":"Hello World --- Robin LEI","slug":"hello-world","date":"2019-08-24T08:05:11.966Z","updated":"2019-08-24T10:04:16.507Z","comments":true,"path":"2019/08/24/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}